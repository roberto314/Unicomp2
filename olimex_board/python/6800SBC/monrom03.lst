                        ;* monrom03.asm  *** 6800 Board Monitor  
                        ;* V3.4 - Updated BASIC to eleminate use of SP as an index pointer.
                        
                            CPU 6800      ;turns additional opcodes off
                           
   0080                 OUTBYTE EQU   $80
   0081                 INBYTE  EQU   $81
   0082                 ADDRH   EQU   $82
   0083                 ADDRL   EQU   $83
   0084                 INDEX1  EQU   $84
   0086                 INDEX2  EQU   $86
   0088                 FLAGS_A EQU   $88
   0089                 TEMP_01 EQU   $89          ; Temp Storage 1
   008a                 TEMP_02 EQU   $8A          ; Temp Storage 2
   008b                 TEMP_03 EQU   $8B          ; Temp Storage 3
   008c                 REC_LEN EQU   $8C          ; iHex Record Length 
   008d                 REC_TYPE EQU  $8D          ; iHex Record Type
   008e                 REC_CSUM EQU  $8E          ; iHex Record Checksum
   0090                 PORTAV  EQU   $90
   0091                 COUNT_A EQU   $91
   0092                 COUNT_B EQU   $92
   0093                 COUNT_C EQU   $93
   0094                 OPCD     EQU  $94          ; Opcode for disassembly
   0095                 ROWADDH  EQU  $95          ; Mnemonic Table Row Address
   0096                 ROWADDL  EQU  $96          
   0097                 OPCFLAGS EQU  $97          ;Opcode flags
   0098                 DISABUFP EQU  $98          ;Dissasmbly buffer pointer (2 bytes)
   009a                 DISADD1  EQU  $9A          ;Disassembly start address (2 bytes)
   009c                 DISADD2  EQU  $9C          ;Disassembly End address (2 bytes)
   009e                 LINECT   EQU  $9E          ;Disassembly Line count 
                        
   00a0                 DISABUF  EQU  $A0          ;Dissasmbly buffer (16 bytes $00-$AF) 
   00b0                 PARMBUF  EQU  $B0          ;Parameter buffer 5 bytes $B0-$B4
   00b5                 PARMLEN  EQU  $B5          ;Parameter Length
   00c0                 IRQVECT  EQU  $C0          ;IRQ Interrupt Vector in FFF8&9
   00c3                 SWIVECT  EQU  $C3          ;SWI Interrupt Vector in FFFA&B
   00c6                 CNTR5MS  EQU  $C6          ;Counts NMI Interrupt every 5ms
                        
                        
   2000                 PORTA   EQU   $2000
   2001                 CTLRA   EQU   $2001 
   2002                 PORTB   EQU   $2002
   2003                 CTLRB   EQU   $2003
                        
                        ;************************************************************************
                        ;  External Call Jump Table  
                        ;  Points to Fixed locations in ROM map to subroutines that may re-locate
                        ;  Copy to Local RAM Programs and un-comment to access ROM functions
                        ;************************************************************************
                        ;DEL5A    EQU  $FFC8          ;Delay  A*5 ms
                        ;DELAYA   EQU  $FFCB          ;Delay  A ms
                        ;DELAYB   EQU  $FFCE          ;Delay B * 6 us
                        ;OUTCHR   EQU  $FFD1          ;Send byte in A to Serial Port
                        ;GETBYTE  EQU  $FFD4          ;wait for a serial byte and return in A
                        ;INCHRE   EQU  $FFD7          ;wait for a serial byte and return in A with echo
                        ;PUTS     EQU  $FFDA          ;Transmit data indexed by X
                        ;OUTHEX   EQU  $FFDD          ;Output A as 2 HEX digits
                        ;GETHEXB  EQU  $FFE0          ;Wait until a HEX byte is entered 
                        ;INHEXB   EQU  $FFE3          ;Input 2 hex digits return with byte value in A
                        ;GETADDR  EQU  $FFE6          ;Get 4 byte address, save in ADDRH & ADDRL 
                        ;BEEPBA   EQU  $FFE9          ;BEEP A=Duration Count and B=Frequency Count
                        ;TESTKEY  EQU  $FFEC          ; Return Z=1 if start bit encountered        
                           
                        ;************************************************************************
                        ;************************************************************************              
                             
   e000                     ORG $E000
                            
                         ;*************************************
                         ; RESET  Start of main program
                         ;**************************************
   e000   8e 07 ff      RESET   LDS	 #$07FF
   e003   0f                    SEI
                                
   e004   86 3b                 LDAA #$3B     ;RTI Instruction  - Populate IRQ Vectors
   e006   97 c0                 STAA IRQVECT
   e008   97 c3                 STAA SWIVECT
                        
   e00a   86 00                 LDAA #$00
   e00c   97 c6                 STAA CNTR5MS    ;Reset 5ms counter LOW & HIGH
   e00e   97 c7                 STAA CNTR5MS+1
                                
   e010   b7 20 01              STAA CTLRA    ;CA.4=0  DDRA Access
   e013   b7 20 03              STAA CTLRB    ;CB.4=0  DDRA Access
   e016   86 ff                 LDAA #$FF
   e018   b7 20 00              STAA PORTA    ;Set DDRA = $FF  All OUTPUTS
   e01b   86 6f                 LDAA #$6F
   e01d   b7 20 02              STAA PORTB    ;Set DDRB = $6F  All OUTPUTS(except Bit 7&4 =INPUT)
   e020   86 04                 LDAA #$04
   e022   b7 20 01              STAA CTLRA    ;CA.4=0  DDRA Access
   e025   b7 20 03              STAA CTLRB    ;CB.4=0  DDRA Access
   e028   86 ff                 LDAA #$FF
   e02a   b7 20 00              STAA PORTA    ;Set PORTA = $FF  All OUTPUTS HIGH (LEDS OFF)
   e02d   86 bf                 LDAA #$BF
   e02f   b7 20 02              STAA PORTB    ;Set DDRB = $BF  All OUTPUTS HIGH (except Bit 6 = RXD)
                                
   e032   86 01                 LDAA #$01     ;Set Echo Flag ON
   e034   97 88                 STAA FLAGS_A
                                
   e036   c6 08                 LDAB #8        ;Blink 8 times
   e038   86 19                 LDAA #25       ;25*5=125ms/state or 1/4 sec per blink
   e03a   bd e1 eb              JSR  BLINKBA
                                
   e03d   86 02                 LDAA #2        ; 1KHZ for 1/2 sec.
   e03f   c6 53                 LDAB #83
   e041   bd e2 0d              JSR  BEEPBA        
                                
   e044   ce e8 fa              LDX  #BOOTMSG
   e047   bd e3 44              JSR  PUTS
   e04a   ce e9 26              LDX  #MSGMENU
   e04d   bd e3 44              JSR  PUTS
                                 
   e050   ce 6c 80      KEYCHK  LDX  #$6C80      ;Set Blink Delay  1/2 sec
   e053   b6 20 02      KEYCHK1 LDAA PORTB       ;Start Bit encountered?
   e056   84 80                 ANDA #$80
   e058   27 1e                 BEQ  GETMOPT     ;Read the key
   e05a   09                    DEX              ;Time to blink?
   e05b   26 f6                 BNE  KEYCHK1     ;NO=Test Key again
   e05d   b6 20 02              LDAA PORTB
   e060   84 01                 ANDA #$01        ;LED ON (PB0=0)
   e062   27 0a                 BEQ  LEDOFF      ;NO=SET LED OFF (PB0=1)
   e064   b6 20 02              LDAA PORTB
   e067   84 fe                 ANDA #$FE        
   e069   b7 20 02              STAA PORTB       ;SET LED ON (PB0=0)
   e06c   20 e2                 BRA  KEYCHK
   e06e   b6 20 02      LEDOFF  LDAA PORTB
   e071   8a 01                 ORAA #$01
   e073   b7 20 02              STAA PORTB       ;SET LED OFF (PB0=1)
   e076   20 d8                 BRA  KEYCHK
                                
   e078   bd e2 81      GETMOPT JSR  GETBYTE
   e07b   bd e2 37              JSR  OUTCHR
   e07e   96 81         CHK_X   LDAA INBYTE
   e080   81 58                 CMPA #'X'
   e082   26 05                 BNE  CHK_B
   e084   bd e1 af              JSR  DOINCA
   e087   20 c7                 BRA  KEYCHK
   e089   81 42         CHK_B   CMPA #'B'        ;BASIC - Cold start
   e08b   26 09                 BNE  CHK_BL
   e08d   ce ea 91              LDX  #MSGBASIC
   e090   bd e3 44              JSR  PUTS
   e093   7e eb 00              JMP  COLDST
   e096   81 62         CHK_BL  CMPA #'b'        ;BASIC - Warm Start
   e098   26 03                 BNE  CHK_N
   e09a   7e f0 9c              JMP  READY
                                
   e09d   81 4e         CHK_N   CMPA #'N'        ;BEEP (N=Noise)
   e09f   26 0a                 BNE  CHK_DL
   e0a1   86 0c                 LDAA #12         ; 1KHZ for 3 sec.
   e0a3   c6 53                 LDAB #83
   e0a5   bd e2 0d              JSR  BEEPBA
   e0a8   7e e1 a6              JMP  MENUXOK       
   e0ab   81 64         CHK_DL  CMPA #'d'        ;Dump 16
   e0ad   26 0e                 BNE  CHK_D
   e0af   bd e2 e8              JSR  GETADDR     ;Enter Address
   e0b2   ce ea 31              LDX  #MSGNL
   e0b5   bd e3 44              JSR  PUTS
   e0b8   bd e3 68              JSR  DUMP16
   e0bb   20 93                 BRA  KEYCHK
   e0bd   81 44         CHK_D   CMPA #'D'        ;Dump 256
   e0bf   26 0e                 BNE  CHK_S
   e0c1   bd e2 e8              JSR  GETADDR     ;Enter Address
   e0c4   ce ea 31              LDX  #MSGNL
   e0c7   bd e3 44              JSR  PUTS
   e0ca   bd e3 c2              JSR  DUMP256
   e0cd   20 a9                 BRA  GETMOPT
   e0cf   81 53         CHK_S   CMPA  #'S'      ;******** Set Memory **********
   e0d1   26 22                 BNE   CHK_F
   e0d3   bd e2 e8              JSR   GETADDR   ;Enter Start Address
   e0d6   25 1a                 BCS   SETMEMX        
   e0d8   ce ea 31              LDX   #MSGNL
   e0db   bd e3 44              JSR   PUTS      ;Newline        
   e0de   bd e2 fe      SETMEM  JSR   INHEXB    ;Get 1 hex byte
   e0e1   25 0f                 BCS   SETMEMX   ;If enter was pressed then exit
   e0e3   de 82                 LDX   ADDRH     ;Get address -> X     
   e0e5   a7 00                 STAA  0,X       ;Store input byte
   e0e7   08                    INX             ;Point at next address
   e0e8   df 82                 STX   ADDRH     ;Save it
   e0ea   86 20                 LDAA  #$20
   e0ec   bd e2 37              JSR   OUTCHR    ;Output a space
   e0ef   7e e0 de              JMP   SETMEM    ;Do it again
   e0f2   7e e1 a6      SETMEMX JMP   MENUXOK   ;Print OK and resume main loop
                        
   e0f5   81 46         CHK_F   CMPA  #'F'       ;******** Fill Memory *******
   e0f7   26 06                 BNE   CHK_G
   e0f9   bd e4 4c              JSR   FILLMEM
   e0fc   7e e1 a6              JMP   MENUXOK   ;Print OK and resume main loop
                                
   e0ff   81 47         CHK_G   CMPA  #'G'      ;**** GO Command **** 
   e101   26 12                 BNE   CHK_GL
   e103   bd e2 e8              JSR   GETADDR   ;Enter Address
   e106   25 39                 BCS   TXTMEMX        
   e108   ce ea 31              LDX   #MSGNL    ;Send Newline
   e10b   bd e3 44              JSR   PUTS
   e10e   de 82                 LDX   ADDRH
   e110   ad 00                 JSR   0,X
   e112   7e e1 a6              JMP   MENUXOK   ;Print OK and resume main loop
                                
   e115   81 67         CHK_GL  CMPA  #'g'      ;******** go 0200 Command **** 
   e117   26 08                 BNE   CHK_T
   e119   ce c0 00              LDX   #$C000    ; Load address of $C000
   e11c   ad 00                 JSR   0,X
   e11e   7e e1 a6              JMP   MENUXOK   ;Print OK and resume main loop  
   e121   81 54         CHK_T   CMPA  #'T'      ;**** Text Chars to Memory ****
   e123   26 1f                 BNE   CHK_L
   e125   bd e2 e8              JSR   GETADDR   ;Enter Start Address
   e128   25 17                 BCS   TXTMEMX        
   e12a   ce ea 31              LDX   #MSGNL
   e12d   bd e3 44              JSR   PUTS      ;Newline        
   e130   bd e2 a8      TXTMEM  JSR   INCHRE    ;Get 1 character and echo
   e133   81 0d                 CMPA  #$0D      ;Is it Return?
   e135   27 0a                 BEQ   TXTMEMX   ;Exit 
   e137   de 82                 LDX   ADDRH     ;Get Address     
   e139   a7 00                 STAA  0,X       ;Save byte
   e13b   08                    INX             ;Inc Address
   e13c   df 82                 STX   ADDRH     ;Save Address
   e13e   7e e1 30              JMP   TXTMEM    ;Repeat
   e141   7e e1 a6      TXTMEMX JMP   MENUXOK   ;Print OK and resume main loop
                        
   e144   81 4c         CHK_L   CMPA  #'L'       ;**** List Memory (Dissamble)****
   e146   26 06                 BNE   CHK_A
   e148   bd e4 8a              JSR   LISTMEM
   e14b   7e e1 a6              JMP   MENUXOK   ;Print OK and resume main loop
                                
   e14e   81 41         CHK_A   CMPA  #'A'       ;**** Assemble to Memory ****
   e150   26 18                 BNE   CHK_Z
   e152   ce ea 55              LDX   #MSGSTART   ;Enter Start Address:
   e155   bd e3 44              JSR   PUTS
   e158   bd e2 fe              JSR   INHEXB      ;Get 2 hex digits
   e15b   25 0a                 BCS   CHK_AX      ; Exit if enter was pressed ...just exit
   e15d   97 82                 STAA  ADDRH
   e15f   bd e2 fe              JSR   INHEXB      ;Get 2 hex digits
   e162   97 83                 STAA  ADDRL
                                
   e164   bd e6 7a              JSR   ASM2MEM   ;Assemble to memory
   e167   7e e1 a6      CHK_AX  JMP   MENUXOK   ;Print OK and resume main loop
                        
   e16a   81 5a         CHK_Z   CMPA #'Z'        ;Blink
   e16c   26 0a                 BNE  CHK_IHR
   e16e   c6 14                 LDAB #20         ;Blink 25 times
   e170   86 19                 LDAA #25         ;25*5=125ms/state or 1/4 sec per blink
   e172   bd e1 eb              JSR  BLINKBA
   e175   7e e1 a6              JMP  MENUXOK 
                        
   e178   81 3a         CHK_IHR CMPA  #$3A       ;**** Get IHEX Rec (no echo) ****
   e17a   26 0c                 BNE   CHK_AT
   e17c   bd e3 e2              JSR   GETIHEX
   e17f   ce ea 31              LDX   #MSGNL
   e182   bd e3 44              JSR   PUTS      ;Newline
   e185   7e e0 78              JMP   GETMOPT
                                
   e188   81 40         CHK_AT  CMPA  #'@'       ;**** Attention Command - Response = "$$$" ****
   e18a   26 09                 BNE   CHK_ML
   e18c   ce ea 8d              LDX   #MSGATNR
   e18f   bd e3 44              JSR   PUTS      ;Attention Response Message = "$$$"
   e192   7e e0 78              JMP   GETMOPT                     
                        
   e195   81 6d         CHK_ML  CMPA  #'m'       ;Display Menu
   e197   27 04                 BEQ   DOMENU
                          
   e199   81 4d         CHK_M   CMPA  #'M'       ;Display Menu
   e19b   26 0f                 BNE   CHK_??
   e19d   ce e9 26      DOMENU  LDX   #MSGMENU
   e1a0   bd e3 44              JSR   PUTS
   e1a3   7e e0 50              JMP   KEYCHK
                                
   e1a6   ce ea 34      MENUXOK LDX   #MSGOK
   e1a9   bd e3 44              JSR   PUTS       
   e1ac   7e e0 50      CHK_??  JMP   KEYCHK 
                         
                        ;*************************************
                        ;DOINCA
                        ;*************************************        
   e1af   7a 20 00      DOINCA  DEC  PORTA
   e1b2   ce 6c 80              LDX  #$6C80      ;Set Blink Delay  1/2 sec
   e1b5   b6 20 02      DOINCA1 LDAA PORTB       ;Start Bit encountered?
   e1b8   84 80                 ANDA #$80
   e1ba   27 05                 BEQ  DOINCAX     ;Exit if key pressed
   e1bc   09                    DEX              ;Time to blink?
   e1bd   26 f6                 BNE  DOINCA1     ;NO=Test Key again
   e1bf   20 ee                 BRA  DOINCA
   e1c1   39            DOINCAX RTS 
                        
                         ;*************************************
                         ; DEL5A 
                         ;**************************************
   e1c2   37            DEL5A   PSHB          ; DEL5A  DELAY A*5 milliseconds (4-1024ms)
   e1c3   c6 00         DEL5A1  LDAB  #00     ; 6us per loop (+14us overhead) (256*6)+14 = 1550us (1.55ms)
   e1c5   bd e1 e7              JSR   DELAYB
   e1c8   bd e1 e7              JSR   DELAYB  ; Just call again for another 1.55ms   (total is now 3.1ms)
   e1cb   bd e1 e7              JSR   DELAYB  ; Just call again for another 1.55ms   (total is now 4.65ms)
   e1ce   c6 38                 LDAB  #56     ; delay the remaining 350us     
   e1d0   bd e1 e7              JSR   DELAYB  
   e1d3   4a                    DECA  
   e1d4   81 00                 CMPA  #$00
   e1d6   26 eb                 BNE   DEL5A1 
   e1d8   33                    PULB
   e1d9   39                    RTS   
                                              
                         ;*************************************
                         ; DELAYA 
                         ;**************************************
   e1da   37            DELAYA   PSHB          ; DELAYA  DELAY A milliseconds
   e1db   c6 a4         DELAYA1 LDAB  #164     ; 6us per loop (= 14us overhead) 164= 998us
   e1dd   bd e1 e7              JSR   DELAYB    
   e1e0   4a                    DECA  
   e1e1   81 00                 CMPA  #$00
   e1e3   26 f6                 BNE   DELAYA1 
   e1e5   33                    PULB
   e1e6   39                    RTS   
                        
                         ;*************************************
                         ; DELAYB 
                         ;**************************************
   e1e7   5a            DELAYB  DECB              ;  DELAYB   6us per count (DECB=2 cycles)
   e1e8   26 fd                 BNE   DELAYB      ; (BNE=4 cycles)
   e1ea   39                    RTS               ; (RTS = 5 cycles)   (* JSR=9 cycles)
                        
                        ;*************************************
                        ; BLINKBA Blink LED ob PB0 B times with 
                        ;         a delay of (A*10)ms   
                        ;************************************* 
   e1eb   37            BLINKBA PSHB
   e1ec   36                    PSHA
   e1ed   b6 20 02      BLINKB1 LDAA PORTB
   e1f0   84 fe                 ANDA #$FE      ; PORTB PB0=0 LED ON
   e1f2   b7 20 02              STAA PORTB
   e1f5   32                    PULA 
   e1f6   36                    PSHA
   e1f7   bd e1 c2              JSR  DEL5A    
   e1fa   b6 20 02              LDAA PORTB
   e1fd   8a 01                 ORAA #$01      ; PORTB PB0=1 LED OFF 
   e1ff   b7 20 02              STAA PORTB
   e202   32                    PULA
   e203   36                    PSHA
   e204   bd e1 c2              JSR  DEL5A    
   e207   5a                    DECB
   e208   26 e3                 BNE  BLINKB1
   e20a   32                    PULA
   e20b   33                    PULB
   e20c   39                    RTS
                        ;******************************************************************
                        ; BEEPBA 
                        ; Call With A=Duratuon Count  B=Frequency Count
                        ; Frequency = (1/12)*Frequency Count or 0.0833 * Frequency Count
                        ; Duration = Frequency Count * 3072 * Duration Count (in microseconds)
                        ;     or Frequency Count * 12 * 256 * Duration Count   
                        ; 7KHz=0x0C 5KHz=0x10 2KHz=0x2A 1KHz=0x53 400Hz=0xD0 327Hz=0xFF                                   
                        ;******************************************************************
   e20d   97 91         BEEPBA STAA  COUNT_A   ;Save Duration Count
                               
   e20f   7a 00 91      DOBEEP DEC   COUNT_A   ;Dec Duration
   e212   27 22                BEQ   DOBEPX    ;If=0  EXIT
   e214   b6 20 02      DOBEP1 LDAA  PORTB
   e217   84 df                ANDA  #$DF
   e219   b7 20 02             STAA  PORTB     ;PB5=LOW
   e21c   37                   PSHB
   e21d   bd e1 e7             JSR   DELAYB
   e220   33                   PULB
   e221   b6 20 02             LDAA  PORTB
   e224   8a 20                ORAA  #$20
   e226   b7 20 02             STAA  PORTB    ;PB5=HIGH
   e229   37                   PSHB
   e22a   bd e1 e7             JSR   DELAYB
   e22d   33                   PULB
   e22e   7a 00 92             DEC   COUNT_B  ;DEC EXTEND DELAY
   e231   26 e1                BNE   DOBEP1 
   e233   7e e2 0f             JMP   DOBEEP
   e236   39            DOBEPX RTS
                        
                         ;*************************************
                         ;OUTCHR  Send Serial 1 byte  
                         ; Delay count: 60 worked for 2400b  8/7 for 9600 
                         ;              25 worked for 4800b 
                         ; * PB6 is INVERTED
                         ;**************************************
   e237   36            OUTCHR  PSHA
   e238   37                    PSHB
   e239   97 80                 STAA OUTBYTE      ; Save OUTBYTE
   e23b   b6 20 02              LDAA PORTB
   e23e   8a 40                 ORAA #$40         ;Set PIN LOW*  (Start Bit)
   e240   b7 20 02              STAA PORTB
   e243   c6 08                 LDAB #8       ; B=Bit Count
   e245   37                    PSHB          ; DELAY 1 bit (416us-2400b 104us =9600) (4 cycles)
   e246   c6 08                 LDAB #8      ; LDAB 2 cycles
   e248   bd e1 e7              JSR  DELAYB   ; (6us / count + 14us for JSR & RTS)
   e24b   33                    PULB
   e24c   96 80         OUTCHR1 LDAA OUTBYTE
   e24e   0c                    CLC
   e24f   46                    RORA
   e250   97 80                 STAA OUTBYTE
   e252   b6 20 02              LDAA PORTB        
   e255   25 04                 BCS  OUTCHR2
   e257   8a 40                 ORAA #$40         ;Set PIN LOW*
   e259   20 02                 BRA  OUTCHR3         
   e25b   84 bf         OUTCHR2 ANDA #$BF         ;Set PIN HIGH*
   e25d   b7 20 02      OUTCHR3 STAA PORTB
                                
   e260   37                    PSHB          ; DELAY 1 bit (416.6us=2400b) (4 cycles)
   e261   c6 07                 LDAB #7       ;                LDAB 2 cycles
   e263   bd e1 e7              JSR  DELAYB   ; 88us   (6us / count + 14us for JSR & RTS)
   e266   33                    PULB
                                
   e267   5a                    DECB
   e268   26 e2                 BNE  OUTCHR1
                                
   e26a   b6 20 02              LDAA PORTB   ; *** Send 2 stop bits
   e26d   84 bf                 ANDA #$BF         ;Set PIN HIGH*
   e26f   b7 20 02              STAA PORTB 
                                   
   e272   c6 7c                 LDAB #124      
   e274   bd e1 e7              JSR  DELAYB   ; 120us   (6us / count + 14us for JSR & RTS)
                                
   e277   33                    PULB
   e278   32                    PULA
   e279   39                    RTS
                                
                        ;*****************************************************
                        ; TESTKEY
                        ; Return Z=1 if start bit encountered
                        ; Remember to delay at least 1ms after this call 
                        ; returns with Z=1 (keypress must be discarded) 
                        ;*****************************************************
   e27a   b6 20 02      TESTKEY LDAA PORTB    ;Read PORTB
   e27d   84 80                 ANDA #$80
   e27f   4d                    TSTA
   e280   39                    RTS
                                
                         ;*************************************
                         ;GETBYTE  Get 1 Serial 1 byte  
                         ; 80/60 worked for 2400 (bit count=8)
                         ; 42/28 worked for 4800
                         ; Used 10/8 with bit count 9 for 9600??
                         ;**************************************
   e281   37            GETBYTE PSHB
                        
   e282   b6 20 02      GETBT1  LDAA PORTB    ;Read PORTA
   e285   84 80                 ANDA #$80
   e287   4d                    TSTA
   e288   26 f8                 BNE  GETBT1   ;No Start Bit - Keep looking
                                
   e28a   c6 15                 LDAB #21      ;Delay 1.5 bit time  ** Was 11 **
   e28c   bd e1 e7      GETBT2  JSR  DELAYB    
   e28f   c6 08                 LDAB #8       ;Set Bit count
                                
   e291   b6 20 02      GETBT3  LDAA PORTB    ;Read PORTA
   e294   49                    ROLA
   e295   96 81                 LDAA INBYTE
   e297   46                    RORA
   e298   97 81                 STAA INBYTE      ; Save INBYTE
                        
   e29a   37                    PSHB          ; DELAY 1 bit (416us=2400 104us=9600) (4 cycles)
   e29b   c6 09                 LDAB #9       ; LDAB 2 cycles
   e29d   bd e1 e7              JSR  DELAYB   ; 54us   (6us / count + 14us for JSR & RTS)
   e2a0   33                    PULB
                                
   e2a1   5a                    DECB
   e2a2   26 ed                 BNE  GETBT3
                                
   e2a4   96 81                 LDAA INBYTE   ; Get INBYTE -> A
   e2a6   33                    PULB
   e2a7   39                    RTS
                        ;**********************************************************
                        ; INCHRE  wait for a serial byte and return in A with echo
                        ;**********************************************************
   e2a8   bd e2 81      INCHRE  JSR   GETBYTE
   e2ab   bd e2 37              JSR   OUTCHR
   e2ae   96 81                 LDAA  INBYTE
   e2b0   39                    RTS        
                        ;*****************************************************
                        ; GETHEXB    Wait for 2 HEX chars to be entered, 
                        ;            return with value in A 
                        ;*****************************************************
   e2b1   bd e2 81      GETHEXB JSR   GETBYTE    ;Get 1 char
   e2b4   81 0d                 CMPA  #$0D       ; Is it CR?
   e2b6   27 2e                 BEQ   GETHEX5    ; Return with C=1
   e2b8   81 1b                 CMPA  #$1B       ; is it Esc?
   e2ba   27 2a                 BEQ   GETHEX5    ; Return with C=1
                        ;        CMPA  #$20
                        ;        BEQ   GETHEX5
                                 
   e2bc   81 30                 CMPA  #"0"        ; < '0'  ?
   e2be   2b f1                 BMI   GETHEXB     ; Get another keystroke
   e2c0   81 67                 CMPA  #"g"        ; > 'f'  ?
   e2c2   2a ed                 BPL   GETHEXB     ; Get another keystroke
   e2c4   81 3a                 CMPA  #$3A        ; <= '9' ?
   e2c6   2a 03                 BPL   GETHEX1     ; NO = continue  else...
   e2c8   7e e2 d7              JMP   GETHEX3     ; Echo & Return
   e2cb   84 4f         GETHEX1 ANDA  #$4F        ;Convert to Uppercase          
   e2cd   81 47                 CMPA  #"G"        ; > 'F' ?
   e2cf   2a e0                 BPL   GETHEXB     ; Get another keystroke
   e2d1   81 40                 CMPA  #$40        ; < 'A' 
   e2d3   23 dc                 BLS   GETHEXB     ; Get another keystroke
   e2d5   97 81                 STAA  INBYTE      ; Save Uppercase version in RX_BYTE
   e2d7   96 88         GETHEX3 LDAA  FLAGS_A
   e2d9   84 01                 ANDA  #$01        ;Is ECHO ON?
   e2db   27 05                 BEQ   GETHEX4     ;NO = Skip OUTCHR
   e2dd   96 81                 LDAA  INBYTE        
   e2df   bd e2 37              JSR   OUTCHR
   e2e2   96 81         GETHEX4 LDAA  INBYTE     ;Get Input byte
   e2e4   0c                    CLC               ;Return with C=0  OK
   e2e5   39                    RTS 
   e2e6   0d            GETHEX5 SEC               ;Return with C=1  Exit Char entered (Esc or CR)
   e2e7   39                    RTS
                           
                        ;;*****************************************************
                        ;; GETADDR Prompt for & input 4 hex chars save value in
                        ;;         ADDR_HI & ADDR_LO
                        ;;*****************************************************
   e2e8   ce ea 45      GETADDR LDX   #MSGENTA   ;Enter Address:
   e2eb   bd e3 44              JSR   PUTS
   e2ee   bd e2 fe      GETADR1 JSR   INHEXB
   e2f1   25 0a                 BCS   GETADDX
   e2f3   97 82                 STAA  ADDRH
   e2f5   bd e2 fe              JSR   INHEXB
   e2f8   25 03                 BCS   GETADDX
   e2fa   97 83                 STAA  ADDRL
   e2fc   0c                    CLC
   e2fd   39            GETADDX RTS
                        ;;*****************************************************
                        ;; INHEXB   Input 2 hex digits return with byte value 
                        ;;          in A    If C=1  exit char was entered
                        ;;*****************************************************
   e2fe   bd e2 b1      INHEXB  JSR   GETHEXB
   e301   25 18                 BCS   INHEXBX
   e303   bd e3 36              JSR   CHR2VAL
   e306   48                    ASLA
   e307   48                    ASLA
   e308   48                    ASLA
   e309   48                    ASLA
   e30a   84 f0                 ANDA  #$F0
   e30c   97 89                 STAA  TEMP_01
   e30e   bd e2 b1              JSR   GETHEXB
   e311   25 08                 BCS   INHEXBX
   e313   bd e3 36              JSR   CHR2VAL
   e316   9a 89                 ORAA  TEMP_01
   e318   97 89                 STAA  TEMP_01
   e31a   0c                    CLC
   e31b   39            INHEXBX RTS
                        
                        ;;*****************************************************
                        ;; INHEXB2  Input 2 hex digits return with byte value in A    
                        ;; No range or error checking - assumes input is HEX char
                        ;;*****************************************************
   e31c   bd e2 81      INHEXB2 JSR   GETBYTE    ;Get 1 char
   e31f   bd e3 36              JSR   CHR2VAL
   e322   48                    ASLA
   e323   48                    ASLA
   e324   48                    ASLA
   e325   48                    ASLA
   e326   84 f0                 ANDA  #$F0
   e328   97 89                 STAA  TEMP_01
   e32a   bd e2 81              JSR   GETBYTE    ;Get 1 char
   e32d   bd e3 36              JSR   CHR2VAL
   e330   9a 89                 ORAA  TEMP_01
   e332   97 89                 STAA  TEMP_01
   e334   0c                    CLC
   e335   39                    RTS
                        ;;*****************************************************
                        ;; CHR2VAL   Convert ASCII hex char to value in A
                        ;;*****************************************************
   e336   81 41         CHR2VAL CMPA  #"A"         ; < 'A'
   e338   2a 03                 BPL   CHR2VL1        
   e33a   84 0f                 ANDA  #$0F
   e33c   39                    RTS
   e33d   80 37         CHR2VL1 SUBA  #55         ; 'A'-'F'
   e33f   39                    RTS        
                               
                        ;;*************************************
                        ;; PUTS                                    
                        ;; PRINT DATA POINTED AT BY X-REG
                        ;;*************************************
   e340   bd e2 37      PUTS2   JSR   OUTCHR
   e343   08                    INX
   e344   a6 00         PUTS    LDAA  0,X
   e346   81 00                 CMPA  #$00
   e348   26 f6                 BNE   PUTS2   ;GO ON IF NOT EOT
   e34a   39                    RTS
                        
                        ;;*************************************
                        ;; OUTNIBH
                        ;; OUTPUT High 4 bits of A as 1 HEX Digit
                        ;; OUTNIBL
                        ;; OUTPUT Low 4 bits of A as 1 HEX Digit
                        ;;*************************************
   e34b   44            OUTNIBH LSRA          ;OUT HEX LEFT HEX DIGIT
   e34c   44                    LSRA
   e34d   44                    LSRA
   e34e   44                    LSRA
   e34f   84 0f         OUTNIBL ANDA  #$0F     ;OUT HEX RIGHT HEX DIGIT
   e351   8a 30                 ORAA  #$30
   e353   81 39                 CMPA  #$39
   e355   23 02                 BLS   OUTNIBX
   e357   8b 07                 ADDA  #$7
   e359   bd e2 37      OUTNIBX JSR   OUTCHR
   e35c   39                    RTS 
                             
                        ;;************************************************************************
                        ;; OUTHEX
                        ;; Output A as 2 HEX digits
                        ;;************************************************************************
   e35d   37            OUTHEX  PSHB            ;Save B
   e35e   16                    TAB             ;Save A in B 
   e35f   bd e3 4b              JSR   OUTNIBH   ;Print High 4 bits
   e362   17                    TBA             ;Get A from B 
   e363   bd e3 4f              JSR   OUTNIBL   ;Print Low 4 Bits
   e366   33                    PULB            ;Restore B
   e367   39                    RTS
                          
                                
                        ;;************************************************************************
                        ;; DUMP16                                                              OK
                        ;; Call with start address in ADDR_HI & ADDR_LO
                        ;;************************************************************************
   e368   96 82         DUMP16  LDAA  ADDRH    ;Print Address as 4 HEX chrs
   e36a   bd e3 5d              JSR   OUTHEX   
   e36d   96 83                 LDAA  ADDRL
   e36f   bd e3 5d              JSR   OUTHEX   
   e372   86 20                 LDAA  #$20       ;Print 2 spaces
   e374   bd e2 37              JSR   OUTCHR   
   e377   bd e2 37              JSR   OUTCHR
   e37a   de 82                 LDX   ADDRH
   e37c   c6 10                 LDAB  #16        ;Set Byte count
   e37e   a6 00         DUMP161 LDAA  0,X        ;Get Data byte
   e380   bd e3 5d              JSR   OUTHEX     ;Print as HEX
   e383   86 20                 LDAA  #$20        
   e385   5a                    DECB
   e386   c1 08                 CMPB  #8         ;On 8th byte print '-' instead of space 
   e388   26 02                 BNE   DUMP162
   e38a   86 2d                 LDAA  #"-"
   e38c   bd e2 37      DUMP162 JSR   OUTCHR
   e38f   08                    INX 
   e390   c1 00                 CMPB  #00        ; Done?
   e392   26 ea                 BNE   DUMP161    ; Do next byte
   e394   bd e2 37              JSR   OUTCHR     ; print 3 spaces
   e397   bd e2 37              JSR   OUTCHR
   e39a   bd e2 37              JSR   OUTCHR
   e39d   de 82                 LDX   ADDRH
   e39f   c6 10                 LDAB  #16        ;Set Byte count
   e3a1   a6 00         DUMP163 LDAA  0,X        ;Get Data byte
   e3a3   81 20                 CMPA  #$20       ;Less than blank? 
   e3a5   2a 02                 BPL   DUMP164
   e3a7   86 2e                 LDAA  #"."
   e3a9   81 7f         DUMP164 CMPA  #$7F       ;Greater than `~`  
   e3ab   2b 02                 BMI   DUMP165
   e3ad   86 2e                 LDAA  #"."
   e3af   bd e2 37      DUMP165 JSR   OUTCHR     ;print it (or the .)
   e3b2   08                    INX
   e3b3   5a                    DECB
   e3b4   c1 00                 CMPB  #00        ;Done?
   e3b6   26 e9                 BNE   DUMP163    ;Do next byte
   e3b8   86 0a                 LDAA  #10
   e3ba   bd e2 37              JSR   OUTCHR     ;Print LF&CR then return
   e3bd   86 0d                 LDAA  #13
   e3bf   7e e2 37              JMP   OUTCHR
                        ;;************************************************************************
                        ;; DUMP256                                                              OK
                        ;; Call with start address in ADDR_HI & ADDR_LO
                        ;;************************************************************************
   e3c2   86 10         DUMP256 LDAA  #16
   e3c4   97 91                 STAA  COUNT_A
   e3c6   bd e3 68      DMP2561 JSR   DUMP16
   e3c9   96 91                 LDAA  COUNT_A
   e3cb   4a                    DECA
   e3cc   81 00                 CMPA  #00
   e3ce   27 11                 BEQ   DMP256X
   e3d0   97 91                 STAA  COUNT_A
   e3d2   0c                    CLC
   e3d3   96 83                 LDAA  ADDRL
   e3d5   89 10                 ADCA   #16
   e3d7   97 83                 STAA  ADDRL
   e3d9   24 eb                 BCC   DMP2561
   e3db   7c 00 82              INC   ADDRH
   e3de   7e e3 c6              JMP   DMP2561
   e3e1   39            DMP256X RTS        
                        ;******************************************************************
                        ; GETIHEX:
                        ; the ':' command - wait for an iHEX record and store it
                        ;                   verify checksum and respond with '*' if OK 
                        ;******************************************************************             
   e3e2   86 00         GETIHEX LDAA  #00     
   e3e4   97 93                 STAA  COUNT_C    ;Clear Checksum
   e3e6   97 91                 STAA  COUNT_A    ;Byte Counter
   e3e8   97 88                 STAA  FLAGS_A    ;Echo Off
                                     
   e3ea   bd e3 1c              JSR   INHEXB2    ;GET RECORD LENGTH
   e3ed   97 8c                 STAA  REC_LEN    ;Save REC LEN
   e3ef   97 91                 STAA  COUNT_A    ;Save in Byte counter
                                          
   e3f1   bd e3 1c              JSR   INHEXB2     ;Get Address save in ADDR_HI & ADDR_LO
   e3f4   97 82                 STAA  ADDRH
   e3f6   bd e3 1c              JSR   INHEXB2
   e3f9   97 83                 STAA  ADDRL        
                        
   e3fb   bd e3 1c              JSR   INHEXB2     ;GET RECORD TYPE
   e3fe   97 8d                 STAA  REC_TYPE   ;Save REC TYPE
                                     
   e400   de 82                 LDX   ADDRH      ;Get Address 
                                                                
   e402   bd e3 1c      NEXTIHB JSR   INHEXB2     ;Get Data Byte
   e405   97 89                 STAA  TEMP_01    ;Save in TEMP_01
   e407   9b 93                 ADDA  COUNT_C    ; Add to Checksum Count
   e409   97 93                 STAA  COUNT_C 
   e40b   96 89                 LDAA  TEMP_01    ; Get input byte   
   e40d   a7 00                 STAA  0,X        ; Store in Memory  
   e40f   08                    INX              ; Inc Address Pointer
   e410   96 91                 LDAA  COUNT_A    ; Get Byte Counter
   e412   4a                    DECA             ; Decrement
   e413   81 00                 CMPA  #00
   e415   27 05                 BEQ   GIHCSUM    ; Done? - Calculate Checksum
   e417   97 91                 STAA  COUNT_A    ; Update Counter
   e419   7e e4 02              JMP   NEXTIHB    ; Get next byte
                        
   e41c   bd e3 1c      GIHCSUM JSR   INHEXB2    ; GET INPUT CHECKSUM 
   e41f   97 8e                 STAA  REC_CSUM   ;Save Checksum
   e421   d6 93                 LDAB  COUNT_C    ; Get Checksum counter ->B
   e423   96 8c                 LDAA  REC_LEN    ; Get Rec Len 
   e425   1b                    ABA              ; Add Total  B+A->A
   e426   16                    TAB              ; Save New Total A->B
   e427   96 8d                 LDAA  REC_TYPE   ; Get Rec Type
   e429   1b                    ABA              ; Add Total  B+A->A
   e42a   16                    TAB              ; Save New Total A->B
   e42b   96 82                 LDAA  ADDRH      ; Address HI
   e42d   1b                    ABA              ; Add Total  B+A->A
   e42e   16                    TAB              ; Save New Total A->B
   e42f   96 83                 LDAA  ADDRL      ; Address LO
   e431   1b                    ABA              ; Add Total
   e432   40                    NEGA             ; 2's complement 
   e433   97 93                 STAA  COUNT_C   ; Save in Checksum counter
   e435   16                    TAB              ; also in B 
                                      
   e436   d1 8e                 CMPB  REC_CSUM  ; Get Input Checksum
   e438   26 03                 BNE   GIHERR2   ; Checksum Error
                                                          ; Otherwise 
   e43a   7e e4 42              JMP   GIHEXIT  ; Good Record - Exit
                                     
                              
   e43d   86 45         GIHERR2 LDAA  #'E'      ; Checksum Error
   e43f   7e e4 44              JMP   GIHEXX1 
                                     
   e442   86 2a         GIHEXIT LDAA  #'*'
   e444   bd e2 37      GIHEXX1 JSR   OUTCHR
   e447   86 01                 LDAA  #$01
   e449   97 88                 STAA  FLAGS_A   ; Turn ECHO BACK ON
   e44b   39                    RTS
                            
                        ;******************************************************
                        ; FILLMEM  Fill Memory routine (F fill)
                        ;******************************************************
   e44c   ce ea 55      FILLMEM LDX   #MSGSTART   ;Enter Start Address:
   e44f   bd e3 44              JSR   PUTS
   e452   bd e2 fe              JSR   INHEXB
   e455   25 32                 BCS   FILLEX
   e457   97 82                 STAA  ADDRH
   e459   bd e2 fe              JSR   INHEXB
   e45c   25 2b                 BCS   FILLEX
   e45e   97 83                 STAA  ADDRL
                                
   e460   ce ea 6d              LDX   #MSGENDAD   ;Enter End Address:
   e463   bd e3 44              JSR   PUTS
   e466   bd e2 fe              JSR   INHEXB
   e469   25 1e                 BCS   FILLEX
   e46b   97 9a                 STAA  DISADD1
   e46d   bd e2 fe              JSR   INHEXB
   e470   25 17                 BCS   FILLEX 
   e472   97 9b                 STAA  DISADD1+1
                                  
   e474   ce ea 85              LDX   #MSGVAL     ;Value:
   e477   bd e3 44              JSR   PUTS
   e47a   bd e2 fe              JSR   INHEXB
                                                  ;Start of fill process
   e47d   de 82                 LDX   ADDRH      ;Get address
   e47f   a7 00         FILL01  STAA  0,X        ;Store the Value
   e481   9c 9a                 CPX   DISADD1    ;Match on End Adress?
   e483   27 04                 BEQ   FILLEX     ;Exit
   e485   08                    INX
   e486   7e e4 7f              JMP   FILL01
   e489   39            FILLEX  RTS    
                                
                        ;;******************************************************************
                        ;; LISTMEM  Disassemble code routine (L List)
                        ;;******************************************************************
   e48a   ce ea 55      LISTMEM LDX   #MSGSTART   ;Enter Start Address:
   e48d   bd e3 44              JSR   PUTS
   e490   bd e2 fe              JSR   INHEXB
   e493   97 9a                 STAA  DISADD1
   e495   bd e2 fe              JSR   INHEXB
   e498   97 9b                 STAA  DISADD1+1
                                
   e49a   86 ff                 LDAA  #$FF
   e49c   97 9e                 STAA  LINECT   ;Default line count to indicate use end address         
                                
   e49e   ce ea 6d              LDX   #MSGENDAD   ;Enter End Address:
   e4a1   bd e3 44              JSR   PUTS
   e4a4   bd e2 fe              JSR   INHEXB
   e4a7   97 9c                 STAA  DISADD2
   e4a9   24 07                 BCC   LIST01      ;If Enter NOT pressed skip ahead else set LINECT=16 
   e4ab   86 10                 LDAA  #16
   e4ad   97 9e                 STAA  LINECT
   e4af   7e e4 bd              JMP   LIST02
   e4b2   bd e2 fe      LIST01  JSR   INHEXB
   e4b5   97 9d                 STAA  DISADD2+1
   e4b7   24 04                 BCC   LIST02      ;If Enter NOT pressed skip ahead else set LINECT=16  
   e4b9   86 10                 LDAA  #16
   e4bb   97 9e                 STAA  LINECT
                                                  ;Start of disassembly
   e4bd   de 9a         LIST02  LDX   DISADD1     ;Get address of opcode
   e4bf   a6 00                 LDAA   0,X        ;Get the opcode and save it in OPCD
   e4c1   97 94                 STAA  OPCD
   e4c3   ce ea 31              LDX   #MSGNL
   e4c6   bd e3 44              JSR   PUTS        ;Print a Newline
                                
   e4c9   bd e6 1a              JSR   OPCTYPE     ;determine opcode type and parmcount
   e4cc   96 94                 LDAA  OPCD
   e4ce   84 c0                 ANDA  #$C0
   e4d0   81 00                 CMPA  #$00
   e4d2   26 06                 BNE   LIST03
   e4d4   bd e6 63              JSR   SRCHMNL     ;Search Mnemonic Table LO for opcode in A
   e4d7   7e e4 e7              JMP   LIST04  
   e4da   bd e6 45      LIST03  JSR   SRCHMNH     ;Search Mnemonic Table HI for opcode in A
   e4dd   81 00                 CMPA  #$00
   e4df   26 15                 BNE   LIST05      ;Continue only if opcode found in table 
   e4e1   ce fc 20              LDX   #MNETBLM    ;Get Table Start Address of table M   
   e4e4   bd e6 48              JSR   SRCHMH1     ;Search Mnemonic Table 'M' for opcode in A
   e4e7   81 00         LIST04  CMPA  #$00
   e4e9   26 0b                 BNE   LIST05      ;Continue only if opcode found in table 
   e4eb   86 3f                 LDAA  #'?'        ;If not found report error
   e4ed   bd e2 37              JSR   OUTCHR
   e4f0   bd e2 37              JSR   OUTCHR
   e4f3   7e e5 ac              JMP   LISTEX           
                                
   e4f6   86 20         LIST05  LDAA  #$20        ;Print a space
   e4f8   bd e2 37              JSR   OUTCHR   
                                                ;DEBUG1
   e4fb   bd e5 ad              JSR   CLRDABUF  ;Clear the disassembly buffer & reset pointer
   e4fe   bd e5 c4              JSR   PUTMNEM   ;Transfer the mnemonic for the opcode found to the disassembly buffer
                                                ;DEBUG2
   e501   96 9a                 LDAA  DISADD1   ;Print Address
   e503   bd e3 5d              JSR   OUTHEX  
   e506   96 9b                 LDAA  DISADD1+1
   e508   bd e3 5d              JSR   OUTHEX  
   e50b   86 20                 LDAA  #$20        ;Print 1 space
   e50d   bd e2 37              JSR   OUTCHR
                                     
   e510   96 94                 LDAA  OPCD
   e512   bd e3 5d              JSR   OUTHEX      ;print Opcode
   e515   86 20                 LDAA  #$20        ;Print 1 space
   e517   bd e2 37              JSR   OUTCHR
                                     
   e51a   96 97                 LDAA  OPCFLAGS    ;Get OPCFLAGA
   e51c   84 03                 ANDA  #$03        ;Mask for parm count (0, 1 or 2)
   e51e   81 00                 CMPA  #$00        ;If zero parms just print spaces
   e520   27 1c                 BEQ   LIST07 
   e522   de 9a                 LDX   DISADD1     ;GET opcode address in X
   e524   81 01                 CMPA  #$01        ;Check parm count .. if 1 only print 1 parm     
   e526   27 0b                 BEQ   LIST06
   e528   08                    INX               ;point X at parm
   e529   a6 00                 LDAA  0,X
   e52b   bd e3 5d              JSR   OUTHEX      ;print parm#
   e52e   86 20                 LDAA  #$20        ;Print 1 space
   e530   bd e2 37              JSR   OUTCHR     
   e533   08            LIST06  INX               ;point X at parm
   e534   a6 00                 LDAA  0,X
   e536   bd e3 5d              JSR   OUTHEX      ;print parm
   e539   86 20                 LDAA  #$20        ;Print 1 space
   e53b   bd e2 37              JSR   OUTCHR     
                                         ;print the appropriate number of spaces based on parm count
   e53e   d6 97         LIST07  LDAB  OPCFLAGS    ;Get OPCFLAGA
   e540   c4 03                 ANDB  #$03        ;Mask for parm count (0, 1 or 2)
   e542   86 04                 LDAA  #$04
   e544   10                    SBA               ;3 - parmcount -> A
   e545   16                    TAB               ;A->B
   e546   86 20         LIST08  LDAA  #$20        ;Print 3 spaces
   e548   bd e2 37              JSR   OUTCHR
   e54b   bd e2 37              JSR   OUTCHR
   e54e   bd e2 37              JSR   OUTCHR        
   e551   5a                    DECB
   e552   c1 00                 CMPB  #$00        ;If not done print 3 more spaces 
   e554   26 f0                 BNE   LIST08 
                                          
   e556   ce 00 a0              LDX   #DISABUF
   e559   bd e3 44              JSR   PUTS        ;Print the Mnemonic buffer
                        
   e55c   de 9a                 LDX   DISADD1     ;GET opcode address
   e55e   96 97                 LDAA  OPCFLAGS    ;Get OPCFLAGA
   e560   84 03                 ANDA  #$03        ;Mask for parm count (0, 1 or 2)
   e562   81 00                 CMPA  #$00        ;If zero parms just update X and exit
   e564   27 10                 BEQ   LIST10
   e566   81 01                 CMPA  #$01        ;Check parm count .. if 1 only print 1 parm     
   e568   27 06                 BEQ   LIST09 
   e56a   08                    INX               ;point X at parm
   e56b   a6 00                 LDAA  0,X
   e56d   bd e3 5d              JSR   OUTHEX     
   e570   08            LIST09  INX               ;point X at parm
   e571   a6 00                 LDAA  0,X
   e573   bd e3 5d              JSR   OUTHEX      ;print parm
                                
   e576   08            LIST10  INX               ;point X at next opcode 
   e577   df 9a                 STX   DISADD1     ;Save new address
   e579   96 97                 LDAA  OPCFLAGS    ;Get OPCFLAGA
   e57b   84 30                 ANDA  #$30        ;Mask for type (0, 1 or 2)
   e57d   81 30                 CMPA  #$30      
   e57f   26 0a                 BNE   LISTNXT     ;If Not type 3 just continue otherwise add ",X" to output
   e581   86 2c                 LDAA  #','
   e583   bd e2 37              JSR   OUTCHR
   e586   86 58                 LDAA  #'X'
   e588   bd e2 37              JSR   OUTCHR
                        
   e58b   96 9e         LISTNXT LDAA  LINECT
   e58d   81 ff                 CMPA  #$FF        ;Using END Address?
   e58f   27 0a                 BEQ   LSTCKEA 
   e591   4a                    DECA
   e592   97 9e                 STAA  LINECT
   e594   81 00                 CMPA  #00
   e596   27 14                 BEQ   LISTEX
   e598   7e e4 bd              JMP   LIST02 
                                 
   e59b   96 9c         LSTCKEA LDAA  DISADD2     ;Get the end address ->X
   e59d   91 9a                 CMPA  DISADD1     ;Subtract current address (next opcode to process)
   e59f   2e 08                 BGT   LSTCKE3     ;End HI > Current Hi keep going
   e5a1   96 9d                 LDAA  DISADD2+1
   e5a3   91 9b                 CMPA  DISADD1+1
   e5a5   24 02                 BCC   LSTCKE3     ;End LO > Current LO keep going
   e5a7   20 03                 BRA   LISTEX
   e5a9   7e e4 bd      LSTCKE3 JMP   LIST02      ;   process the next opcode                            
   e5ac   39            LISTEX  RTS
                        
                        ;******************************************************************
                        ;CLRDABUF
                        ;******************************************************************
   e5ad   ce 00 a0      CLRDABUF LDX  #DISABUF
   e5b0   86 20                 LDAA  #$20
   e5b2   a7 00         CLRDAB1 STAA  0,X
   e5b4   08                    INX
   e5b5   8c 00 af              CPX   #DISABUF+15
   e5b8   26 f8                 BNE   CLRDAB1
   e5ba   86 00                 LDAA  #$00
   e5bc   a7 00                 STAA  0,X
   e5be   ce 00 a0              LDX   #DISABUF
   e5c1   97 98                 STAA  DISABUFP
   e5c3   39                    RTS 
                        
                        ;******************************************************************
                        ; PUTMNEM
                        ; transfer the mnemonic for the opcode found to the disassembly buffer
                        ; populate the parameter format that will be used
                        ;******************************************************************
   e5c4   ce 00 a0      PUTMNEM LDX   #DISABUF
   e5c7   df 98                 STX   DISABUFP 
   e5c9   de 95         PUTMNE1 LDX   ROWADDH
   e5cb   a6 00                 LDAA  0,X
   e5cd   08                    INX
   e5ce   df 95                 STX   ROWADDH
   e5d0   de 98                 LDX   DISABUFP
   e5d2   a7 00                 STAA  0,X
   e5d4   08                    INX 
   e5d5   df 98                 STX   DISABUFP
   e5d7   8c 00 a4              CPX   #DISABUF+4
   e5da   26 ed                 BNE   PUTMNE1
                                
   e5dc   96 97                 LDAA  OPCFLAGS   ;Add 'A' or 'B' if indicated by flags
   e5de   84 0c                 ANDA  #$0C
   e5e0   81 04                 CMPA  #$04
   e5e2   26 07                 BNE   PUTMNE2
   e5e4   86 41                 LDAA  #'A'
   e5e6   97 a3                 STAA  DISABUF+3
   e5e8   7e e5 f3              JMP   PUTMNE3
   e5eb   81 08         PUTMNE2 CMPA  #$08
   e5ed   26 04                 BNE   PUTMNE3
   e5ef   86 42                 LDAA  #'B'
   e5f1   97 a3                 STAA  DISABUF+3
   e5f3   96 97         PUTMNE3 LDAA  OPCFLAGS
   e5f5   84 30                 ANDA  #$30
   e5f7   81 00                 CMPA  #$00
   e5f9   26 05                 BNE   PUTMNE4
   e5fb   86 00                 LDAA  #$00
   e5fd   97 a6                 STAA  DISABUF+6
   e5ff   39                    RTS         
   e600   81 10         PUTMNE4 CMPA  #$10
   e602   26 0d                 BNE   PUTMNE5
   e604   86 23                 LDAA  #'#'
   e606   97 a6                 STAA  DISABUF+6         
   e608   86 24                 LDAA  #'$'
   e60a   97 a7                 STAA  DISABUF+7
   e60c   86 00                 LDAA  #$00
   e60e   97 a8                 STAA  DISABUF+8
   e610   39                    RTS
   e611   86 24         PUTMNE5 LDAA  #'$'
   e613   97 a6                 STAA  DISABUF+6
   e615   86 00                 LDAA  #$00        
   e617   97 a7                 STAA  DISABUF+7
   e619   39                    RTS
                        
                        ;******************************************************************
                        ;OPCTYPE  Set OPCFLAGS indicating type, action and parm count 
                        ;         RETURN with OPCFLAGS in A
                        ;******************************************************************
   e61a   ce fb 00      OPCTYPE LDX   #OPCDTYPE ;Get address of OPCDTYPE lookup table in X
   e61d   d6 94                 LDAB  OPCD      ;Get opcode
   e61f   54                    LSRB            ;Shift hi bits to low 4 bits 
   e620   54                    LSRB
   e621   54                    LSRB
   e622   54                    LSRB                        
   e623   c4 0f                 ANDB  #$0F      ;mask high 4 bits
   e625   bd e8 e1              JSR   ADDB2X    ;add B to X (replaces ABX)
   e628   a6 00                 LDAA  0,X       ;Get the flags from the table
   e62a   97 97                 STAA  OPCFLAGS  ;Store in OPCFLAGS
   e62c   84 03                 ANDA  #$03      ;Mask parm count bits
   e62e   81 00                 CMPA  #$00      ; If Zero no parms
   e630   27 12                 BEQ   OPCTYPX   ; so just exit  .. otherwise...          
   e632   ce fb 10      OPCEXCP LDX   #OPCDEXCP ; Check exception table 
   e635   d6 94                 LDAB  OPCD
   e637   a6 00         OPCEXP1 LDAA  0,X        
   e639   81 00                 CMPA  #00
   e63b   27 07                 BEQ   OPCTYPX
   e63d   08                    INX 
   e63e   11                    CBA
   e63f   26 f6                 BNE   OPCEXP1
   e641   7c 00 97              INC   OPCFLAGS  ;If found add 1 to parm count
                                
   e644   39            OPCTYPX RTS
                          
                        ;******************************************************************
                        ;SRCHMNH    Search Mnemonic Table 'H' 
                        ;******************************************************************
   e645   ce fb 20      SRCHMNH LDX   #MNETBLH   ;Get Table Start Address
   e648   df 95         SRCHMH1 STX   ROWADDH    ;Save in ROWADDH & L
   e64a   08                    INX              ;Skip past Mnemonic bytes
   e64b   08                    INX
   e64c   08                    INX
   e64d   08                    INX
   e64e   c6 04                 LDAB  #$04      ;byte count = 4 (4 bytes per mnemonic row)
   e650   a6 00         SRCHMH2 LDAA  0,X       ;Get opcode from table
   e652   91 94                 CMPA  OPCD      ;compare to save opcode
   e654   27 0c                 BEQ   SRCHMHX   ;Match found then exit
                                                ; else
   e656   08                    INX             ;point next opcode 
   e657   5a                    DECB            ;dec byte count
   e658   c1 00                 CMPB  #00       ;done with this mnemonic/row
   e65a   26 f4                 BNE   SRCHMH2   ;not yet .. then test this opcode 
   e65c   a6 00                 LDAA  0,X       ;get 1st byte from next row
   e65e   81 00                 CMPA  #00       ;zero indicates end of table reached - search failed
   e660   26 e6                 BNE   SRCHMH1   ; not zero then keep looking
   e662   39            SRCHMHX RTS   ; otherwise return with A=0
                        
                        ;******************************************************************
                        ;SRCHMNL    Search Mnemonic Table 'L'
                        ;******************************************************************
   e663   ce fc 88      SRCHMNL LDX   #MNETBLL   ;Get Table Start Address
   e666   df 95         SRCHML1 STX   ROWADDH    ;Save in ROWADDH & L
   e668   08                    INX              ;Skip past Mnemonic bytes
   e669   08                    INX
   e66a   08                    INX
   e66b   08                    INX
   e66c   a6 00         SRCHML2 LDAA  0,X       ;Get opcode from table
   e66e   91 94                 CMPA  OPCD      ;compare to save opcode
   e670   27 07                 BEQ   SRCHMLX   ;Match found then exit
                                                ; else
   e672   08                    INX             ;point start of next row 
   e673   a6 00                 LDAA  0,X       ;get 1st byte from next row
   e675   81 00                 CMPA  #00       ;zero indicates end of table reached - search failed
   e677   26 ed                 BNE   SRCHML1   ; not zero then keep looking
   e679   39            SRCHMLX RTS   ; otherwise return with A=0
                        
                        ;;************************************************************************
                        ;;  Assemble Function ASM2MEM
                        ;;************************************************************************
                        ;;******************************************************************
                        ;; ASM2MEM  Assemble to Memory function
                        ;;    Call with start address in ADDR_HI & ADDR_LO
                        ;;******************************************************************        
   e67a   86 00         ASM2MEM LDAA  #$00        ;Reset line count
   e67c   97 9e                 STAA  LINECT
                                
   e67e   ce ea 31              LDX   #MSGNL
   e681   bd e3 44              JSR   PUTS      ;Newline
                                
   e684   96 82                 LDAA  ADDRH     ;Print Address
   e686   bd e3 5d              JSR   OUTHEX
   e689   96 83                 LDAA  ADDRL
   e68b   bd e3 5d              JSR   OUTHEX
   e68e   86 20                 LDAA  #$20      ;Print a space
   e690   bd e2 37              JSR   OUTCHR
                                
   e693   bd e5 ad              JSR   CLRDABUF  ; Clear input buffer
   e696   bd e8 b1              JSR   GETSTR    ; Input 1 line of text
   e699   df 98                 STX   DISABUFP  ; save buffer exit position
   e69b   96 99                 LDAA  DISABUFP+1 
   e69d   81 a3                 CMPA  #DISABUF+3
   e69f   24 01                 BCC   ASM201      
   e6a1   39            ASM2X1  RTS             ; Less than 3 bytes entered = DONE just exit
                                
   e6a2   bd e8 76      ASM201  JSR   DESPACE   ; Remove spaces from input
   e6a5   bd e8 3d              JSR   MOVPRM    ; Move parm bytes to PARMBUF & set PARMLEN
   e6a8   bd e7 b1              JSR   SETTYPE   ; Set type flags
   e6ab   81 ff                 CMPA  #$FF      ;Check for error
   e6ad   26 03                 BNE   ASM202
   e6af   7e e7 4c              JMP   ASM2ERX
                                
   e6b2   ce fc 88      ASM202  LDX   #MNETBLL  ;Address of MNETBLL->X
   e6b5   c6 05                 LDAB  #$05      ; Table Row length ->B
   e6b7   bd e7 f1              JSR   ASMSH4    ;Search Table L
   e6ba   81 00                 CMPA  #$00
   e6bc   26 61                 BNE   ASM2PR    ;if found search continue to process...
                                
   e6be   86 00         ASM2SH  LDAA  #$00        ;Reset line count
   e6c0   97 9e                 STAA  LINECT
   e6c2   ce fb 20              LDX   #MNETBLH  ;Address of MNETBLH->X
   e6c5   c6 08                 LDAB  #$08
   e6c7   bd e7 f1              JSR   ASMSH4    ;Search Table H
   e6ca   81 00                 CMPA  #$00
   e6cc   27 1d                 BEQ   ASM2SM    ; if not found search table M
   e6ce   d6 97                 LDAB  OPCFLAGS  ; Get Type 0,1,2,4 or 8
   e6d0   c1 02                 CMPB  #$02
   e6d2   26 05                 BNE   ASM2SH1
   e6d4   a6 05                 LDAA  5,X       ;if type=2 use opcode col#1
   e6d6   7e e7 1f              JMP   ASM2PR
   e6d9   c1 04         ASM2SH1 CMPB  #$04        
   e6db   26 05                 BNE   ASM2SH2
   e6dd   a6 06                 LDAA  6,X       ;if type=4 use opcode col#2
   e6df   7e e7 1f              JMP   ASM2PR
   e6e2   c1 08         ASM2SH2 CMPB  #$08        
   e6e4   26 39                 BNE   ASM2PR
   e6e6   a6 07                 LDAA  7,X       ;if type=8 use opcode col#3
   e6e8   7e e7 1f              JMP   ASM2PR    ; else using opcd col#0 (already saved)
                                
   e6eb   86 00         ASM2SM  LDAA  #$00        ;Reset line count
   e6ed   97 9e                 STAA  LINECT
   e6ef   ce fc 20              LDX   #MNETBLM  ;Address of MNETBLM->X 
   e6f2   c6 08                 LDAB  #$08
   e6f4   bd e8 13              JSR   ASMSH3    ;Search Table M (compare 1st 3 bytes only)
   e6f7   81 00                 CMPA  #$00
   e6f9   27 51                 BEQ   ASM2ERX     ;if not found --> ERROR exit 
   e6fb   d6 a3                 LDAB  DISABUF+3  ;Check 4th mnemonic byte
   e6fd   c1 41                 CMPB  #'A'
   e6ff   26 05                 BNE   ASM2SM1
   e701   a6 06                 LDAA  6,X       ;if='A' use opcode col#2
   e703   7e e7 1f              JMP   ASM2PR
   e706   c1 42         ASM2SM1 CMPB  #'B'
   e708   26 05                 BNE   ASM2SM2
   e70a   a6 07                 LDAA  7,X       ;if='B' use opcode col#3
   e70c   7e e7 1f              JMP   ASM2PR        
   e70f   d6 97         ASM2SM2 LDAB  OPCFLAGS  ;4th byte must be blank so ..Get Type 0,1,2,4 or 8
   e711   c1 04                 CMPB  #$04
   e713   26 05                 BNE   ASM2SM3
   e715   a6 04                 LDAA  4,X       ;if type=4 use opcode col#0
   e717   7e e7 1f              JMP   ASM2PR    ;  else
   e71a   a6 05         ASM2SM3 LDAA  5,X       ; use opcode col#1
   e71c   7e e7 1f              JMP   ASM2PR        
                        
   e71f   97 94         ASM2PR  STAA  OPCD
   e721   de 82                 LDX   ADDRH     ;Store opcode..
   e723   96 94                 LDAA  OPCD
   e725   a7 00                 STAA  0,X        
   e727   df 9c                 STX   DISADD2
                                 
   e729   86 20                 LDAA  #$20      ;Print a space
   e72b   bd e2 37      ASMPAD  JSR   OUTCHR
   e72e   7c 00 99              INC   DISABUFP+1   ;Pad with spaces depending on input line length
   e731   d6 99                 LDAB  DISABUFP+1
   e733   c1 af                 CMPB  #DISABUF+15        
   e735   25 f4                 BCS   ASMPAD   
                                
   e737   96 94                 LDAA  OPCD                
   e739   bd e3 5d              JSR   OUTHEX   ;Print OPCODE and 1 space
   e73c   86 20                 LDAA  #$20     ;Print a space
   e73e   bd e2 37              JSR   OUTCHR
   e741   bd e7 78              JSR   CVTPRMS
   e744   bd e7 53              JSR   OUTPRMS
   e747   df 82                 STX   ADDRH
   e749   7e e6 7a              JMP   ASM2MEM   ; process another line of input
                        
   e74c   ce ea 3b      ASM2ERX LDX   #MSGERR   ;print ERROR message
   e74f   bd e3 44              JSR   PUTS
   e752   39            ASM2END RTS
                        
                        ;******************************************************************
                        ; OUTPRMS  Output values in PARMBUF move parm data to target memory 
                        ;  Call with X=target address 
                        ;  returns with X updated to next target address
                        ;******************************************************************
   e753   08            OUTPRMS INX             ;Skip past opcode location
   e754   96 b5                 LDAA  PARMLEN   ;Get Parm buffer pointer
   e756   81 b0                 CMPA  #PARMBUF  ; $70 = NO PARMS
   e758   26 01                 BNE   OUTPRM1
   e75a   39                    RTS             ; exit if no parms
   e75b   96 b0         OUTPRM1 LDAA  PARMBUF   ; get 1st parm byte
   e75d   a7 00                 STAA  0,X       ; save to target address
   e75f   08                    INX             ; point to next address
   e760   bd e3 5d              JSR   OUTHEX    ; print parm byte
   e763   86 20                 LDAA  #$20      ;Print a space
   e765   bd e2 37              JSR   OUTCHR
   e768   96 b5                 LDAA  PARMLEN   ;Get Parm buffer pointer
   e76a   81 b4                 CMPA  #PARMBUF+4      ; $74= 2 bytes of parm data
   e76c   27 01                 BEQ   OUTPRM2   ; If = $74 continue
   e76e   39                    RTS             ; else exit
   e76f   96 b1         OUTPRM2 LDAA  PARMBUF+1 ; get 2nd parm byte, save, print & exit 
   e771   a7 00                 STAA  0,X
   e773   08                    INX
   e774   bd e3 5d              JSR   OUTHEX
   e777   39                    RTS
                        
                        ;******************************************************************
                        ; CVTPRMS   convert ASCII in PARMBUF to value(s) in PARMBUF 
                        ;******************************************************************
   e778   d6 b5         CVTPRMS LDAB  PARMLEN    ;Get parm buffer pointer
   e77a   c1 b0                 CMPB  #PARMBUF   ;$70 = NO PARMS
   e77c   26 01                 BNE   CVTPRM1    ;If we do have parm data continue..
   e77e   39                    RTS              ;else exit
   e77f   96 b0         CVTPRM1 LDAA  PARMBUF    ;Get 1st parm character
   e781   bd e3 36              JSR   CHR2VAL    ;convert to it's HEX value
   e784   48                    ASLA             ;Shift LEFT 4x
   e785   48                    ASLA
   e786   48                    ASLA
   e787   48                    ASLA
   e788   84 f0                 ANDA  #$F0       ;Mask low 4bits
   e78a   97 b0                 STAA  PARMBUF    ;Save it
   e78c   96 b1                 LDAA  PARMBUF+1  ;Get 2nd parm character
   e78e   bd e3 36              JSR   CHR2VAL    ;Convert to HEX value
   e791   9b b0                 ADDA  PARMBUF    ;combine with 1st byte data
   e793   97 b0                 STAA  PARMBUF    ;Save it 
   e795   c1 b4                 CMPB  #PARMBUF+4   ; PARMLEN = $74 = 2 parm bytes
   e797   27 01                 BEQ   CVTPRM2
   e799   39                    RTS              ;if only 1 byte entered just exit
   e79a   96 b2         CVTPRM2 LDAA  PARMBUF+2  ;Get 3rd parm character      
   e79c   bd e3 36              JSR   CHR2VAL    ;convert to it's HEX value   
   e79f   48                    ASLA             ;Shift LEFT 4x               
   e7a0   48                    ASLA                                          
   e7a1   48                    ASLA                                          
   e7a2   48                    ASLA                                          
   e7a3   84 f0                 ANDA  #$F0       ;Mask low 4bits              
   e7a5   97 b1                 STAA  PARMBUF+1  ;Save it                     
   e7a7   96 b3                 LDAA  PARMBUF+3  ;Get 4th parm character      
   e7a9   bd e3 36              JSR   CHR2VAL    ;Convert to HEX value        
   e7ac   9b b1                 ADDA  PARMBUF+1  ;combine with 3rd byte data  
   e7ae   97 b1                 STAA  PARMBUF+1  ;Save it                     
   e7b0   39                    RTS
                        
                        ;******************************************************************
                        ; SETTYP Set the type flags in OPCFLAGS
                        ;      type4 may already  have already been set if indexed ('X')
                        ;      was detected in DESPACE. 
                        ;      Type 0 = IMPLIED, 1=IMMEDIATE, 2=DIRECT, 4=INDEXED, 8=EXTENDED
                        ;******************************************************************        
   e7b1   96 b5         SETTYPE LDAA  PARMLEN   ;Get Parmlen  
   e7b3   81 b0                 CMPA  #PARMBUF      ;$70 = zero length NO PARMs
   e7b5   26 05                 BNE   SETTYP4   
   e7b7   86 00                 LDAA  #$00      ;set type=0
   e7b9   7e e7 e6              JMP   SETTYPA   ;Save type & exit
   e7bc   96 97         SETTYP4 LDAA  OPCFLAGS
   e7be   81 04                 CMPA  #$04       ;Indexed flag set? (set in DESPACE)
   e7c0   26 01                 BNE   SETTYP1
   e7c2   39                    RTS
   e7c3   96 a4         SETTYP1 LDAA  DISABUF+4  
   e7c5   81 23                 CMPA  #'#'        ;'#' indicates immediate instruction  
   e7c7   26 0b                 BNE   SETTYP2
   e7c9   96 a5                 LDAA  DISABUF+5  ;Next byte MUST be '$' else ERROR     
   e7cb   81 24                 CMPA  #'$'
   e7cd   26 1d                 BNE   SETTYPX
   e7cf   86 01                 LDAA  #$01       ;set type=1
   e7d1   7e e7 e6              JMP   SETTYPA        
   e7d4   96 a4         SETTYP2 LDAA  DISABUF+4        
   e7d6   81 24                 CMPA  #'$'        ;If 1st byte afer mnemonic is not '#' it MUST be '$'
   e7d8   26 12                 BNE   SETTYPX    ;   else ERROR
   e7da   86 02                 LDAA  #$02
   e7dc   97 97                 STAA  OPCFLAGS   ;Could be type 2 or 8... start with type 2 
   e7de   96 b5                 LDAA  PARMLEN
   e7e0   81 b4                 CMPA  #PARMBUF+4  ;if 4 parm bytes the set type 8
   e7e2   26 05                 BNE   SETTYPN     ; else leave it at 2
   e7e4   86 08                 LDAA  #$08
   e7e6   97 97         SETTYPA STAA  OPCFLAGS    ;save result
   e7e8   39                    RTS
                                
   e7e9   96 97         SETTYPN LDAA  OPCFLAGS    ;always return with flags in A
   e7eb   39                    RTS
                                
   e7ec   86 ff         SETTYPX LDAA  #$FF        ;Syntax ERROR return code = $FF
   e7ee   97 97                 STAA  OPCFLAGS
   e7f0   39                    RTS         
                                
                        ;******************************************************************
                        ; ASMSH4   Compare the first 4 bytes of mnemonic with table value
                        ; call with X loaded with start of table and b=table row len (8 or 5)
                        ; updates LINECT with table row# and OPCD with return value
                        ; returns with next table byte set or A=0 if not found
                        ;******************************************************************
   e7f1   bd e8 13      ASMSH4  JSR   ASMSH3
   e7f4   81 00                 CMPA  #$00
   e7f6   27 08                 BEQ   ASMSH4X
   e7f8   96 a3                 LDAA  DISABUF+3
   e7fa   a1 03                 CMPA  3,X
   e7fc   26 05                 BNE   ASMSH4N
   e7fe   a6 04                 LDAA  4,X
   e800   97 94         ASMSH4X STAA  OPCD
   e802   39                    RTS
   e803   0c            ASMSH4N CLC
   e804   bd e8 e1              JSR   ADDB2X    ;add B to X (replaces ABX)
   e807   a6 00                 LDAA  0,X
   e809   81 00                 CMPA  #00
   e80b   27 f3                 BEQ   ASMSH4X
   e80d   7c 00 9e              INC   LINECT
   e810   7e e7 f1              JMP   ASMSH4
                        
                        ;******************************************************************
                        ; ASMSH3   Compare the first 3 bytes of mnemonic with table value
                        ; call with X loaded with start of table and b=table row len (8 or 5)
                        ; updates LINECT with table row# and OPCD with return value
                        ; returns with next table byte set or A=0 if not found 
                        ;******************************************************************
   e813   bd e8 2c      ASMSH3  JSR   ASMCMP3  ;compare 3 byte of mnemonic data
   e816   26 05                 BNE   ASMSH3N  ;match failed try next row
   e818   a6 03                 LDAA  3,X      ;match found
   e81a   97 94         ASMSH3X STAA  OPCD     ;save last matched byte in OPCD and exit A!=0 
   e81c   39                    RTS             
   e81d   bd e8 e1      ASMSH3N JSR   ADDB2X    ;add B to X (replaces ABX) Point X at start of next table row
   e820   a6 00                 LDAA  0,X      ;Check 1st byte of mnemonic
   e822   81 00                 CMPA  #00      ;if this is a zero - end of table - search failed
   e824   27 f4                 BEQ   ASMSH3X  ;exit with A=0  OPCD=0  
   e826   7c 00 9e              INC   LINECT   ; else add 1 to line counter
   e829   7e e8 13              JMP   ASMSH3   ;continue search
                        
                        ;******************************************************************
                        ; ASMCMP3   Compare the first 3 bytes of mnemonic with table value
                        ;          call with X loaded with start of bytes to compare
                        ;          returns Z flag set if all 3 match or cleared if not 
                        ;******************************************************************
   e82c   96 a0         ASMCMP3 LDAA  DISABUF
   e82e   a1 00                 CMPA  0,X
   e830   26 0a                 BNE   ASMCP3X
   e832   96 a1                 LDAA  DISABUF+1
   e834   a1 01                 CMPA  1,X
   e836   26 04                 BNE   ASMCP3X
   e838   96 a2                 LDAA  DISABUF+2
   e83a   a1 02                 CMPA  2,X
   e83c   39            ASMCP3X RTS
                        
                        ;******************************************************************
                        ; MOVPRM   Move parameter bytes from input buffer to PARMBUF
                        ;          set PARMLEN to offset of last byte+1
                        ;******************************************************************
   e83d   86 b0         MOVPRM  LDAA  #PARMBUF        
   e83f   97 b5                 STAA  PARMLEN    ;Reset parm length pointer
   e841   86 00                 LDAA  #$00
   e843   97 af                 STAA  DISABUF+15  ;Make sure buffer is terminated
   e845   ce 00 a3              LDX   #DISABUF+3  ;Set X = start of data-1
   e848   08            MOVPRM1 INX               ;Next byte
   e849   a6 00                 LDAA   0,X        ;Get Byte
   e84b   81 00                 CMPA  #$00        ;Is it = 0 (end of buffer)
   e84d   27 26                 BEQ   MOVPRMX     ; Done        
   e84f   81 2f                 CMPA  #$2F        ;Is it < '0'
   e851   23 f5                 BLS   MOVPRM1     ;Keep looking
   e853   81 47                 CMPA  #'G'        ;Is it >'F'
   e855   24 1e                 BCC   MOVPRMX     ; Done 
   e857   df 84                 STX   INDEX1      ;Save X
   e859   d6 b5                 LDAB  PARMLEN     ;Get parm buf pointer
   e85b   c1 b4                 CMPB  #PARMBUF+4  ;Parm Buffer Full?
   e85d   27 0f                 BEQ   MOVPRM3
   e85f   ce 00 00              LDX   #$0000
   e862   bd e8 e1              JSR   ADDB2X    ;add B to X (replaces ABX) parm buf pointer -> X
   e865   a7 00                 STAA  0,X         ;Save parm byte in parm buf
   e867   7c 00 b5              INC   PARMLEN     ;inc parmlen
   e86a   86 00                 LDAA  #$00        ;Terminate parm buffer
   e86c   a7 01                 STAA  1,X 
   e86e   de 84         MOVPRM3 LDX   INDEX1       ;restore x
   e870   8c 00 b0              CPX   #DISABUF+16  ;end of buffer reached?
   e873   26 d3                 BNE   MOVPRM1     ; keep going ... otherwise return
   e875   39            MOVPRMX RTS        
                        
                        ;******************************************************************
                        ; DESPACE  Remove spaces from buffer  detect 'X' in buffer
                        ;******************************************************************
   e876   86 00         DESPACE LDAA  #00
   e878   97 97                 STAA  OPCFLAGS      ;CLEAR ALL FLAGS 
   e87a   ce 00 a4              LDX   #DISABUF+4       
   e87d   a6 00         DSPACE1 LDAA   0,X          ;Get A Byte
   e87f   81 58                 CMPA  #'X'          ;If we encounter an 'X' set bit 2 of OPCFLAGS
   e881   26 04                 BNE   DSPACE2
   e883   86 04                 LDAA  #$04          ;Set type=4(indexed) if we encounter 'X'
   e885   97 97                 STAA  OPCFLAGS 
   e887   81 20         DSPACE2 CMPA  #$20          ;Is the byte a space?
   e889   26 06                 BNE   DSPACE3       ;NO= Process next byte
   e88b   bd e8 a2              JSR   SHIFTBL       ;YES=Shift everything left 1 position
   e88e   7e e8 7d              JMP   DSPACE1       ;Continue...
   e891   08            DSPACE3 INX                 
   e892   8c 00 af              CPX   #DISABUF+15   ;Processed entire buffer?
   e895   26 e6                 BNE   DSPACE1       ;No = Continue
   e897   96 a3                 LDAA  DISABUF+3
   e899   81 00                 CMPA  #$00
   e89b   26 04                 BNE   DESPACX
   e89d   86 20                 LDAA  #$20
   e89f   97 a3                 STAA  DISABUF+3  
   e8a1   39            DESPACX RTS
                        
                        ;******************************************************************
                        ; SHIFTBL  Shift DISABUF left 1 position
                        ;******************************************************************
   e8a2   df 84         SHIFTBL STX   INDEX1
   e8a4   a6 01         SHFTBL1 LDAA  1,X
   e8a6   a7 00                 STAA  0,X
   e8a8   08                    INX
   e8a9   8c 00 af              CPX   #DISABUF+15
   e8ac   26 f6                 BNE   SHFTBL1
   e8ae   de 84                 LDX   INDEX1
   e8b0   39                    RTS
                                
                        ;******************************************************************
                        ; GETSTR  Input up to 16bytes and store in DISABUF
                        ;******************************************************************
   e8b1   ce 00 a0      GETSTR  LDX   #DISABUF
   e8b4   bd e2 81      GETSTR1 JSR   GETBYTE       ;Get a byte
   e8b7   81 0d                 CMPA  #$0D        ;Is It CR?  
   e8b9   27 21                 BEQ   GETSTRX     ; if so then exit
   e8bb   81 7f                 CMPA  #$7F        ; Backspace?
   e8bd   26 0c                 BNE   GETSTR2
   e8bf   8c 00 a0              CPX   #DISABUF
   e8c2   27 f0                 BEQ   GETSTR1
   e8c4   09                    DEX
   e8c5   bd e2 37              JSR   OUTCHR
   e8c8   7e e8 b4              JMP   GETSTR1
   e8cb   81 5a         GETSTR2 CMPA  #'Z'         ;  <=Z?
   e8cd   2b 02                 BMI   GETSTR3     ; dont convert
   e8cf   84 5f                 ANDA  #$5F        ;Convert to UPPERCASE
   e8d1   bd e2 37      GETSTR3 JSR   OUTCHR      ;echo it
   e8d4   a7 00                 STAA  0,X         ; Save the byte
   e8d6   08                    INX               ;Inc buffer pointer
   e8d7   8c 00 b0              CPX   #DISABUF+16  ;Buffer Full?
   e8da   26 d8                 BNE   GETSTR1     ; If not then get another byte else exit
   e8dc   86 00         GETSTRX LDAA  #$00        ; Terminate buffer with $00
   e8de   a7 00                 STAA  0,X
   e8e0   39                    RTS
                        ;*************************************
                        ; ADDB2X
                        ; Use in place of ABX instruction
                        ;*************************************
   e8e1   37            ADDB2X  PSHB            ; Save B
   e8e2   df 86                 STX   INDEX2    ; X -> INDEX1
   e8e4   db 87                 ADDB  INDEX2+1  ;Add X-LOW to B 
   e8e6   d7 87                 STAB  INDEX2+1  ;Put Results in INDEX1_LO
   e8e8   24 03                 BCC   ADDB2X1   ;Overflow?  
   e8ea   7c 00 86              INC   INDEX2    ;Add 1 to INDEX1_HI
   e8ed   de 86         ADDB2X1 LDX   INDEX2    ;Load X with results
   e8ef   33                    PULB            ;Restore B
   e8f0   39                    RTS 
                        
                        ;*************************************
                        ; NMI Interrupt Service Routine every 5ms
                        ;*************************************
   e8f1   7c 00 c7      NMIISR  INC  CNTR5MS+1
   e8f4   26 03                 BNE  NMIISRX
   e8f6   7c 00 c6              INC  CNTR5MS
   e8f9   3b            NMIISRX RTI           
                                
                        ;*************************************
                        ; Messages
                        ;*************************************
   e8fa   0d 0a         BOOTMSG  FCB  $0D,$0A  
   e8fc   2a 2a 20 36            FCC  "** 6800 CPU Board ROM V03.4 11/30/17 **"
   e900   38 30 30 20   
   e904   43 50 55 20   
   e908   42 6f 61 72   
   e90c   64 20 52 4f   
   e910   4d 20 56 30   
   e914   33 2e 34 20   
   e918   31 31 2f 33   
   e91c   30 2f 31 37   
   e920   20 2a 2a      
   e923   0d 0a 00               FCB  $0D,$0A,$00
   e926   0d 0a         MSGMENU  FCB  $0D,$0A
   e928   20 2a 2a 20            FCC  " ** 6800 MPU Main Menu **"
   e92c   36 38 30 30   
   e930   20 4d 50 55   
   e934   20 4d 61 69   
   e938   6e 20 4d 65   
   e93c   6e 75 20 2a   
   e940   2a            
   e941   0d 0a                  FCB  $0D,$0A
   e943   20 64 20 20            FCC  " d  Dump 16 Bytes        D  Dump 256 Bytes"
   e947   44 75 6d 70   
   e94b   20 31 36 20   
   e94f   42 79 74 65   
   e953   73 20 20 20   
   e957   20 20 20 20   
   e95b   20 44 20 20   
   e95f   44 75 6d 70   
   e963   20 32 35 36   
   e967   20 42 79 74   
   e96b   65 73         
   e96d   0d 0a                  FCB  $0D,$0A
   e96f   20 53 20 20            FCC  " S  Set Memory           F  Fill Memory"
   e973   53 65 74 20   
   e977   4d 65 6d 6f   
   e97b   72 79 20 20   
   e97f   20 20 20 20   
   e983   20 20 20 20   
   e987   20 46 20 20   
   e98b   46 69 6c 6c   
   e98f   20 4d 65 6d   
   e993   6f 72 79      
   e996   0d 0a                  FCB  $0D,$0A
   e998   20 54 20 20            FCC  " T  Text to Memory     G/g  Execute"
   e99c   54 65 78 74   
   e9a0   20 74 6f 20   
   e9a4   4d 65 6d 6f   
   e9a8   72 79 20 20   
   e9ac   20 20 20 47   
   e9b0   2f 67 20 20   
   e9b4   45 78 65 63   
   e9b8   75 74 65      
   e9bb   0d 0a                  FCB  $0D,$0A
   e9bd   20 42 2f 62            FCC  " B/b BASIC               N  Beep"
   e9c1   20 42 41 53   
   e9c5   49 43 20 20   
   e9c9   20 20 20 20   
   e9cd   20 20 20 20   
   e9d1   20 20 20 20   
   e9d5   20 4e 20 20   
   e9d9   42 65 65 70   
   e9dd   0d 0a                  FCB  $0D,$0A
   e9df   20 4c 20 20            FCC  " L  List(Dis-Assemble)   A  Assemble"
   e9e3   4c 69 73 74   
   e9e7   28 44 69 73   
   e9eb   2d 41 73 73   
   e9ef   65 6d 62 6c   
   e9f3   65 29 20 20   
   e9f7   20 41 20 20   
   e9fb   41 73 73 65   
   e9ff   6d 62 6c 65   
   ea03   0d 0a                  FCB  $0D,$0A
   ea05   20 5a 20 20            FCC  " Z  Blink LEDs           M/m Re-Display Menu"
   ea09   42 6c 69 6e   
   ea0d   6b 20 4c 45   
   ea11   44 73 20 20   
   ea15   20 20 20 20   
   ea19   20 20 20 20   
   ea1d   20 4d 2f 6d   
   ea21   20 52 65 2d   
   ea25   44 69 73 70   
   ea29   6c 61 79 20   
   ea2d   4d 65 6e 75   
                                 
   ea31   0d 0a 00      MSGNL    FCB  $0D,$0A,$00         
   ea34   0d 0a 4f 4b   MSGOK    FCB  $0D,$0A,$4F,$4B,$0D,$0A,$00   ;CRLF OK CRLF
   ea38   0d 0a 00      
   ea3b   0d 0a         MSGERR   FCB  $0D,$0A
   ea3d   45 52 52 4f            FCC  "ERROR"
   ea41   52            
   ea42   0d 0a 00               FCB  $0D,$0A,$00
   ea45   20 45 6e 74   MSGENTA  FCC  " Enter Address:"
   ea49   65 72 20 41   
   ea4d   64 64 72 65   
   ea51   73 73 3a      
   ea54   00                     FCB  $00 
   ea55   0a 0d         MSGSTART FCB $0A,$0D
   ea57   20 45 6e 74            FCC " Enter Start Address:"
   ea5b   65 72 20 53   
   ea5f   74 61 72 74   
   ea63   20 41 64 64   
   ea67   72 65 73 73   
   ea6b   3a            
   ea6c   00                     FCB $00
   ea6d   0a 0d         MSGENDAD FCB $0A,$0D
   ea6f   20 45 6e 74            FCC " Enter End   Address:"
   ea73   65 72 20 45   
   ea77   6e 64 20 20   
   ea7b   20 41 64 64   
   ea7f   72 65 73 73   
   ea83   3a            
   ea84   00                     FCB $00   
   ea85   20 56 61 6c   MSGVAL   FCC " Value:"
   ea89   75 65 3a      
   ea8c   00                     FCB  $00                
   ea8d   24 24 24      MSGATNR  FCC  "$$$"
   ea90   00                     FCB  $00 
   ea91   0a 0d         MSGBASIC FCB $0A,$0D
   ea93   20 20 4e 41            FCC "  NAM MICRO  MICROBASIC  V2.3A"
   ea97   4d 20 4d 49   
   ea9b   43 52 4f 20   
   ea9f   20 4d 49 43   
   eaa3   52 4f 42 41   
   eaa7   53 49 43 20   
   eaab   20 56 32 2e   
   eaaf   33 41         
   eab1   0d 0a 00               FCB  $0D,$0A,$00 
                        
                        
   eb00                     ORG $EB00          ;**** BASIC on even page address *****
                        
                        ;*******************************************************
                        ; NAM MICRO  MICROBASIC
                        ;* ***** VERSION 1.3A *****
                        ;* BY ROBERT H UITERWYK, TAMPA, FLORIDA
                        ;*
                        ;* MODIFIED TO RUN ON THE MC3
                        ;* BY DANIEL TUFVESSON (DTU) 2013
                        ;*
                        ;* ADDITIONAL BUGFIXES
                        ;* BY LES HILDENBRANDT (LHI) 2013
                        ;* 
                        ;* Updated for 6800 Board by Eric M. Klaus  11/28/2017
                        ;**********************************************************
   0072                 MAXLIN    EQU    $72	 ; dc.b 72     ; Max Line Length
   007f                 BACKSP    EQU    $7F	 ; dc.b $7F    ;// EMK puTTY backspace = 127
   001b                 CANCEL    EQU    $1B	 ; dc.b $1B    ;// EMK Use ESC as cancel
                               
                        ;  **** ORG $0120  *** MEMORY VARIABLES *****
   0001                 LOCAL     EQU    $01     ;Make this match Temp storage High Byte Address
   0120                 INDEX_1   EQU    $0120     
   0122                 INDEX_2   EQU    $0122
   0124                 INDEX_3   EQU    $0124	  
   0126                 INDEX_4   EQU    $0126	  
   0128                 SAVEXP    EQU    $0128	  
   012a                 NEXTBA    EQU    $012A	 ;  dc.w END  
   012c                 WORKBA    EQU    $012C	 ;  dc.w END  
   012e                 SOURCE    EQU    $012E	 ;  dc.w END  
   0130                 PACKLN    EQU    $0130	  
   0132                 HIGHLN    EQU    $0132	  
   0134                 BASPNT    EQU    $0134	  
   0136                 BASLIN    EQU    $0136	  
   0138                 PUSHTX    EQU    $0138	  
   013a                 XSTACK    EQU    $013A	 ; dc.w $707F 
   013c                 RNDVAL    EQU    $013C	  
   013e                 DIMPNT    EQU    $013E	  
   0140                 DIMCAL    EQU    $0140	  
   0142                 PRCNT     EQU    $0142	 ; Print counter
   0146                 MEMEND    EQU    $0146	 ; dc.w $6FFF 	;FDB $1FFF 			#### /DTU
   0148                 ARRTAB    EQU    $0148	  
   014a                 KEYWD     EQU    $014A	  
   014c                 TSIGN     EQU    $014C	   
   014d                 NCMPR     EQU    $014D	   
   014e                 TNUMB     EQU    $014E	   
   014f                 ANUMB     EQU    $014F	   
   0150                 BNUMB     EQU    $0150	   
   0151                 AESTK     EQU    $0151	 ; dc.w ASTACK 
   0153                 FORPNT    EQU    $0153	 ; dc.w FORSTK 
   0155                 VARPNT    EQU    $0155	 ; dc.w VARTAB 
   0157                 SBRPNT    EQU    $0157	 ; dc.w SBRSTK 
   0159                 SBRSTK    EQU    $0159	   
   0169                 FORSTK    EQU    $0169	 
   0199                 DIMVAR    EQU    $0199	 ;dc.w VARTAB      
   01ac                 BUFNXT    EQU    $01AC	 ;dc.w $00B0 
   01ae                 ENDBUF    EQU    $01AE	 ;dc.w $00B0
   01b0                 BUFFER    EQU    $01B0	 
   0200                 VARTAB    EQU    $0200	 
   028c                 ASTACK    EQU    $028C
   028e                 INDEX_5   EQU    $028E
   0290                 INDEX_6   EQU    $0290
   0292                 PUSHXP    EQU    $0292
   0294                 SRCHPA    EQU    $0294
   0296                 SRCHPB    EQU    $0296
   0298                 DESTPA    EQU    $0298
   029a                 DESTPB    EQU    $029A
                        
   02b0                 BASICTOP	EQU    $02B0   ;Use this in ROM implementation	 
                                  
                        ;;     ORG $C000
                               
   eb00   ce 01 20      COLDST  LDX  #INDEX_1
   eb03   4f                    CLRA
   eb04   a7 00         CLRVMEM STAA 0,X
   eb06   08                    INX
   eb07   8c 02 8c              CPX  #ASTACK
   eb0a   26 f8                 BNE  CLRVMEM
                                
   eb0c   ce 02 b0      INITVM  LDX  #BASICTOP     ;Init the menory variables(USE #BASICTOP for ROM version $03B0)
   eb0f   ff 01 2a              STX  NEXTBA          
   eb12   ff 01 2c              STX  WORKBA          
   eb15   ff 01 2e              STX  SOURCE        
   eb18   ce 07 7f              LDX  #$077F         ;Was $707F, $D07f
   eb1b   ff 01 3a              STX  XSTACK        
   eb1e   ce 06 ff              LDX  #$06FF         ;Was $6FFF  $CFFF
   eb21   ff 01 46              STX  MEMEND        
   eb24   ce 02 8c              LDX  #ASTACK
   eb27   ff 01 51          	  STX  AESTK         
   eb2a   ce 01 69              LDX  #FORSTK
   eb2d   ff 01 53           	  STX  FORPNT        
   eb30   ce 02 00              LDX  #VARTAB
   eb33   ff 01 55           	  STX  VARPNT        
   eb36   ce 01 59              LDX  #SBRSTK
   eb39   ff 01 57           	  STX  SBRPNT                
   eb3c   ce 02 00              LDX  #VARTAB
   eb3f   ff 01 99              STX  DIMVAR        
   eb42   ce 01 b0              LDX  #BUFFER 
   eb45   ff 01 ac              STX  BUFNXT         
   eb48   ff 01 ae              STX  ENDBUF        
                                
   eb4b   7e f0 76      PROGM   JMP  START		;	Start Basic
   eb4e   52 55 4e      COMMAN  FCC "RUN"
   eb51   1e                    FCB $1E
   eb52   f1 05                 FDB RUN
   eb54   4c 49 53 54           FCC "LIST"
   eb58   1e                    FCB $1E
   eb59   f1 3b                 FDB CLIST 
   eb5b   4e 45 57              FCC "NEW"
   eb5e   1e                    FCB $1E
   eb5f   f0 76                 FDB START
   eb61   50 41 54              FCC "PAT"
   eb64   1e                    FCB $1E
   eb65   f1 81                 FDB PATCH
   eb67   53 59 53              FCC "SYS"
   eb6a   1e                    FCB $1E
   eb6b   f1 91                 FDB SYSCALL
   eb6d   50 45 45 4b           FCC "PEEK"
   eb71   1e                    FCB $1E
   eb72   f1 d1                 FDB DOPEEK        
   eb74   50 4f 4b 45           FCC "POKE"
   eb78   1e                    FCB $1E
   eb79   f1 ea                 FDB DOPOKE        
   eb7b   47 4f 53 55   GOLIST  FCC "GOSUB"
   eb7f   42            
   eb80   1e                    FCB $1E
   eb81   f3 2d                 FDB GOSUB
   eb83   47 4f 54 4f           FCC "GOTO"
   eb87   1e                    FCB $1E
   eb88   f3 58                 FDB GOTO
   eb8a   47 4f 20 54           FCC "GO TO"
   eb8e   4f            
   eb8f   1e                    FCB $1E
   eb90   f3 58                 FDB GOTO
   eb92   53 49 5a 45           FCC "SIZE"
   eb96   1e                    FCB $1E
   eb97   f5 a2                 FDB SIZE
   eb99   54 48 45 4e           FCC "THEN"
   eb9d   1e                    FCB $1E
   eb9e   f7 8d                 FDB IF2
   eba0   50 52 49 4e           FCC "PRINT"
   eba4   54            
   eba5   1e                    FCB $1E
   eba6   f4 71                 FDB PRINT
   eba8   4c 45 54              FCC "LET"
   ebab   1e                    FCB $1E
   ebac   f5 7d         IMPLET  FDB LET
   ebae   49 4e 50 55           FCC "INPUT"
   ebb2   54            
   ebb3   1e                    FCB $1E
   ebb4   f3 a9                 FDB INPUT
   ebb6   49 46                 FCC "IF"
   ebb8   1e                    FCB $1E
   ebb9   f7 75                 FDB IF
   ebbb   45 4e 44              FCC "END"
   ebbe   1e                    FCB $1E
   ebbf   f0 9c                 FDB READY
   ebc1   52 45 54 55           FCC "RETURN"
   ebc5   52 4e         
   ebc7   1e                    FCB $1E
   ebc8   f3 6d                 FDB RETURN
   ebca   44 49 4d              FCC "DIM"
   ebcd   1e                    FCB $1E
   ebce   f5 cc                 FDB DIM
   ebd0   46 4f 52              FCC "FOR"
   ebd3   1e                    FCB $1E
   ebd4   f6 95                 FDB FOR
   ebd6   4e 45 58 54           FCC "NEXT"
   ebda   1e                    FCB $1E
   ebdb   f7 13                 FDB NEXT
   ebdd   52 45 4d              FCC "REM"
   ebe0   1e                    FCB $1E
   ebe1   f5 c6                 FDB REMARK
   ebe3   50 41 55 53   PAUMSG  FCC "PAUSE"
   ebe7   45            
   ebe8   1e                    FCB $1E
   ebe9   f3 87                 FDB PAUSE
   ebeb   20                    FCB $20
   ebec   1e            COMEND  FCB $1E
   ebed   f5 7d                 FDB LET
                                
   ebef   0d            RDYMSG  FCB $0D
   ebf0   0a                    FCB $0A
   ebf1   52 45 41 44           FCC "READY"
   ebf5   59            
   ebf6   1e                    FCB $1E
   ebf7   23            PROMPT  FCB $23
   ebf8   1e                    FCB $1E
   ebf9   1e                    FCB $1E
   ebfa   10            PGCNTL  FCB $10
   ebfb   16                    FCB $16
   ebfc   1e                    FCB $1E
   ebfd   1e                    FCB $1E
   ebfe   1e                    FCB $1E
   ebff   45 52 52 4f   ERRMS1  FCC "ERROR# "
   ec03   52 23 20      
   ec06   1e                    FCB $1E
   ec07   20 49 4e 20   ERRMS2  FCC " IN LINE "
   ec0b   4c 49 4e 45   
   ec0f   20            
   ec10   1e                    FCB $1E
                        
                                ; *** SUBROUTINE KEYBD  GET Keyboard Input  ***
   ec11   86 3f         KEYBD   LDAA #$3F         ; Print "?"
   ec13   8d 4e                 BSR OUTCH
   ec15   ce 01 b0      KEYBD0  LDX #BUFFER       ; X= Start of input buffer
   ec18   c6 0a                 LDAB #10          ; B=10
   ec1a   8d 4d         KEYBD1  BSR INCH          ; Wait for 1 byte of keyboard input
   ec1c   81 00                 CMPA #$00         ; Is it Break ?  Timeout? 
   ec1e   26 06                 BNE KEYB11        ; NO = Continue
   ec20   5a                    DECB              ; Count it ...
   ec21   26 f7                 BNE KEYBD1	      ; If we don't have 10 then continue - otherwise  
   ec23   7e f0 9c      KEYB10  JMP READY         ; Warm start - wait for new input line
   ec26   81 1b         KEYB11  CMPA #CANCEL      ; Is it Cancel? (Esc)
   ec28   27 26                 BEQ DEL           ; Yes = Discard all input and keep waiting
   ec2a   81 0d                 CMPA #$0D         ; Is it Enter?
   ec2c   27 2b                 BEQ IEXIT         ; YES = Exit
   ec2e   81 0a         KEYBD2  CMPA #$0A         ; Is it LF?
   ec30   27 e8                 BEQ KEYBD1        ; Ignore
   ec32   81 15                 CMPA #$15         ; Is it  NAK ?
   ec34   27 e4                 BEQ KEYBD1        ; Ignore
   ec36   81 13                 CMPA #$13         ; Is it DC3?
   ec38   27 e0                 BEQ KEYBD1        ; Ignore
   ec3a   81 7f         KEYB55  CMPA #BACKSP      ; Is it Backspace?
   ec3c   26 08                 BNE KEYBD3        ; No = Continue
   ec3e   8c 01 b0              CPX #BUFFER       ; Yes = process Backspace
   ec41   27 d7                 BEQ KEYBD1        ; If At startof buffer just ignore BS 
   ec43   09                    DEX               ; Back up X
   ec44   20 d4                 BRA KEYBD1        ; Continue waiting...
   ec46   8c 01 f7      KEYBD3  CPX #BUFFER+71    ; End of input buffer reached?
   ec49   27 cf                 BEQ KEYBD1        ; Ignore input, keep waiting for input...
   ec4b   a7 00                 STAA 0,X          ; Save the input byte
   ec4d   08                    INX               ; Inc pointer
   ec4e   20 ca                 BRA KEYBD1        ; Keep waiting for input...
                                
   ec50   8d 2d         DEL     BSR CRLF          ;Print Newline
   ec52   ce eb f7      CNTLIN  LDX #PROMPT       ;Print "#"
   ec55   8d 21                 BSR OUTNCR
   ec57   20 bc                 BRA KEYBD0        ;Clear input and keep waiting....
                                  
   ec59   86 1e         IEXIT   LDAA #$1E         ;Got Enter key   
   ec5b   a7 00                 STAA ,X           ; store EOT marker $1E
   ec5d   ff 01 ae              STX ENDBUF        ; Save End of input in ENDBUF
   ec60   8d 1d                 BSR CRLF          ;Print Newline and exit
   ec62   39                    RTS               
                        
   ec63   bd f8 0e      OUTCH   JSR CHKBRK	     ; Test for key press otherwise output 1 byte
   ec66   7e e2 37      ECHO    JMP OUTCHR       
                        
   ec69   bd e2 81      INCH    JSR  GETBYTE     ; * SUBROUTINE INCH  get 1 byte of keyboard input ***
   ec6c   81 1b                 CMPA #CANCEL     ; ESC = EXIT
   ec6e   26 f6                 BNE  ECHO        ; Otherwise print it and return
   ec70   39                    RTS
                        
                                                         
   ec71   8d 05         OUTPUT  BSR  OUTNCR  ;Send chars based on X, to terminal until $1E is encountered
   ec73   20 0a                 BRA  CRLF    ;Output Newline and return
                        
   ec75   8d ec         OUTPU2  BSR  OUTCH   ; Output 1 byte 
   ec77   08            OUTPU3  INX          ; Advance byte pointer
   ec78   a6 00         OUTNCR  LDAA 0,X     ; Get byte pointed to by X
   ec7a   81 1e                 CMPA #$1E    ; EOL?
   ec7c   26 f7                 BNE  OUTPU2  ; NO = Output It
   ec7e   39                    RTS          ; YES = Return
                        
   ec7f   8d 10         CRLF    BSR PUSHX    ; * SUBROUTINE CRLF * Send CR & LF (X is retained)
   ec81   ce ec 89              LDX #CRLFST
   ec84   8d f2                 BSR OUTNCR
   ec86   8d 24                 BSR PULLX
   ec88   39                    RTS
                        
   ec89   0d            CRLFST  FCB $0D      ; CR LF + EOL storage
   ec8a   0a                    FCB $0A
   ec8b   1e            CREND   FCB $1E
   ec8c   ff ff                 FCB $FF,$FF
   ec8e   ff ff                 FCB $FF,$FF
   ec90   1e                    FCB $1E
                                
   ec91   ff 01 38      PUSHX   STX PUSHTX      ;PUSH X into  XSTACK  (A & X unchanged) 
   ec94   fe 01 3a              LDX XSTACK
   ec97   09                    DEX
   ec98   09                    DEX
   ec99   ff 01 3a              STX XSTACK
   ec9c   36                    PSHA
   ec9d   b6 01 38              LDAA PUSHTX
   eca0   a7 00                 STAA 0,X
   eca2   b6 01 39              LDAA PUSHTX+1
   eca5   a7 01                 STAA 1,X
   eca7   32                    PULA
   eca8   fe 01 38              LDX PUSHTX
   ecab   39                    RTS
                        
   ecac   fe 01 3a      PULLX   LDX XSTACK     ;PULL X from  XSTACK 
   ecaf   ee 00                 LDX 0,X
   ecb1   7c 01 3b              INC XSTACK+1
   ecb4   7c 01 3b              INC XSTACK+1
   ecb7   39                    RTS
                        
   ecb8   36            STORE   PSHA           ; subroutine:STORE A & B at address from AESTK
   ecb9   37                    PSHB           ;Save A & B
   ecba   8d d5                 BSR PUSHX      ;Save X in XSTACK
   ecbc   bd ee 6c              JSR PULLAE     ;Get A & B from AESTK 
   ecbf   fe 01 51              LDX AESTK      ;Increment AESTK pointer
   ecc2   08                    INX            
   ecc3   08                    INX
   ecc4   ff 01 51              STX AESTK
   ecc7   09                    DEX            ;X= Original AESTK pointer+1
   ecc8   ee 00                 LDX 0,X        ;Get X from AESTK
   ecca   a7 00                 STAA 0,X       ;STORE A
   eccc   e7 01                 STAB 1,X       ;STORE B
   ecce   8d dc                 BSR PULLX      ;Restore X,B,A and return
   ecd0   33                    PULB
   ecd1   32                    PULA
   ecd2   39                    RTS
                        
   ecd3   8d bc         IND     BSR PUSHX      ; subroutine: PUSH 16bit value pointed by AESTK onto AESTK
   ecd5   36                    PSHA
   ecd6   37                    PSHB
   ecd7   fe 01 51              LDX AESTK
   ecda   08                    INX
   ecdb   08                    INX
   ecdc   ff 01 51              STX AESTK
   ecdf   09                    DEX
   ece0   ee 00                 LDX 0,X
   ece2   a6 00                 LDAA 0,X
   ece4   e6 01                 LDAB 1,X
   ece6   bd ee 59              JSR PUSHAE
   ece9   33                    PULB
   ecea   32                    PULA
   eceb   8d bf                 BSR PULLX
   eced   39                    RTS
                        
   ecee   fe 01 2a      LIST    LDX NEXTBA    ; SUBROUTINE LIST 
   ecf1   ff 01 2c              STX WORKBA    ; WORKBA = NEXTBA (End of code buffer)
   ecf4   fe 01 2e              LDX SOURCE    ; X = SOURCE (Start of code buffer)
   ecf7   20 03                 BRA LIST1
   ecf9   fe 01 24      LIST0   LDX INDEX_3   ; Get X from INDEX_3 (enter here to list a specific line#)
   ecfc   bc 01 2c      LIST1   CPX WORKBA    ; X= End of code buffer?
   ecff   27 05                 BEQ LEXIT     ; YES = EXIT 
   ed01   8d 04                 BSR OUTLIN    ; NO= Output 1 line of code 
   ed03   08                    INX           ; X=X+1
   ed04   20 f6                 BRA LIST1     ; Keep Going until X=WORKBA
   ed06   39            LEXIT   RTS
                        
   ed07   a6 00         OUTLIN  LDAA 0,X      ; SUBROUTINE OUTLIN Output 1 line of code (call with X=start of code line)
   ed09   7f 01 42              CLR PRCNT     ; Reset print column counter
   ed0c   08                    INX           ; X=X+1
   ed0d   e6 00                 LDAB 0,X      ; Get Line# (Low Byte)
   ed0f   08                    INX
   ed10   7f 01 4c              CLR TSIGN
   ed13   bd f5 35              JSR PRN0       ;Print Line#
   ed16   8d 26                 BSR PRINSP     ;Print a space
   ed18   a6 00         OUTLI1  LDAA 0,X       ;Get Keyword Token
   ed1a   08                    INX
   ed1b   bd ec 91              JSR PUSHX      ;Save X
   ed1e   ce eb 4e              LDX #COMMAN    
   ed21   ff 01 4a              STX KEYWD      ;KEYWD = Start of Table
   ed24   b7 01 4b              STAA KEYWD+1   ;KEYWD Low byte = keyword token (offset into table)
   ed27   fe 01 4a              LDX KEYWD      ;X = Address of Keyword execution address
   ed2a   09                    DEX
   ed2b   09            OUTLI2  DEX            ;X = Address of end of keyword text
   ed2c   a6 00                 LDAA 0,X       ;Get 1 byte of keyword text
   ed2e   81 1e                 CMPA #$1E      ;EOL?
   ed30   26 f9                 BNE OUTLI2     ; NO = Continue search for start of keyword text... 
   ed32   08                    INX            ; Yes = skip X past EOL & address pointer
   ed33   08                    INX
   ed34   08                    INX             
   ed35   bd ec 78              JSR OUTNCR     ; Print byte till EOL. (NO CR)
   ed38   bd ec ac              JSR PULLX      ; Restore X
   ed3b   7e ec 71              JMP OUTPUT     ; Advance X and print newline then exit.
                        
   ed3e   36            PRINSP  PSHA         ;SUBROUTINE Print a space (A is unchanged)
   ed3f   86 20                 LDAA #$20
   ed41   bd ec 63              JSR OUTCH
   ed44   32                    PULA
   ed45   39                    RTS
                        
   ed46   08            RANDOM  INX
   ed47   08                    INX
   ed48   a6 00                 LDAA 0,X
   ed4a   81 44                 CMPA #'D'
   ed4c   26 74                 BNE  TSTVER
   ed4e   bd ec 91              JSR PUSHX
   ed51   b6 01 3c              LDAA RNDVAL
   ed54   f6 01 3d              LDAB RNDVAL+1
   ed57   ce 00 00              LDX  #0000
   ed5a   e9 01         RAND1   ADCB 1,X
   ed5c   a9 00                 ADCA 0,X
   ed5e   08                    INX
   ed5f   08                    INX
   ed60   8c 01 3c              CPX #RNDVAL
   ed63   26 f5                 BNE  RAND1
   ed65   84 7f                 ANDA #$7F
   ed67   b7 01 3c              STAA RNDVAL
   ed6a   f7 01 3d              STAB RNDVAL+1
   ed6d   ff 01 20              STX  INDEX_1
   ed70   b6 01 20              LDAA INDEX_1
   ed73   f6 01 21              LDAB INDEX_1+1
   ed76   7e ee 3a              JMP   TSTV9
                        
   ed79   bd ef fa      TSTV    JSR   SKIPSP
   ed7c   bd f8 0e      	      JSR   CHKBRK              ;JSR BREAK			#### /DTU
   ed7f   bd ee 43              JSR   TSTLTR
   ed82   24 01                 BCC   TSTV1
   ed84   39                    RTS
                        
   ed85   81 52         TSTV1   CMPA #'R'
   ed87   26 06                 BNE TSTV2
   ed89   e6 01                 LDAB 1,X
   ed8b   c1 4e                 CMPB #'N'
   ed8d   27 b7                 BEQ  RANDOM
   ed8f   bd ec 91      TSTV2   JSR PUSHX
   ed92   80 40                 SUBA #$40
   ed94   b7 01 56              STAA VARPNT+1
   ed97   48                    ASLA
   ed98   bb 01 56              ADDA VARPNT+1
   ed9b   b7 01 56              STAA VARPNT+1
   ed9e   fe 01 55              LDX VARPNT
   eda1   b6 01 55              LDAA VARPNT
   eda4   f6 01 56              LDAB VARPNT+1
   eda7   6d 02                 TST  2,X
   eda9   26 03                 BNE  TSTV20
   edab   7e ee 3a              JMP  TSTV9
                        
   edae   ee 00         TSTV20  LDX  0,X
   edb0   ff 01 3e              STX  DIMPNT
   edb3   08                    INX
   edb4   08                    INX
   edb5   ff 01 40              STX DIMCAL
   edb8   bd ec ac              JSR  PULLX
   edbb   bd f0 00              JSR INXSKP
   edbe   81 28                 CMPA #'('
   edc0   27 03                 BEQ TSTV22
   edc2   7e f3 fb      TSTVER  JMP DBLLTR
   edc5   08            TSTV22  INX
   edc6   bd ee c3              JSR EXPR
   edc9   bd ec 91              JSR PUSHX
   edcc   bd ee 6c              JSR PULLAE
   edcf   4d                    TSTA
   edd0   27 03                 BEQ TSTV3
   edd2   7e f6 20      SUBER1  JMP  SUBERR
                        
   edd5   fe 01 3e      TSTV3   LDX DIMPNT
   edd8   5d                    TSTB
   edd9   27 f7                 BEQ  SUBER1
   eddb   e1 00                 CMPB 0,X
   eddd   22 f3                 BHI  SUBER1
   eddf   a6 01                 LDAA 1,X
   ede1   b7 01 4f              STAA ANUMB
   ede4   27 34                 BEQ TST666
   ede6   fe 01 40              LDX DIMCAL
   ede9   5a            TSTV4   DECB
   edea   27 0a                 BEQ TSTV6
   edec   b6 01 4f              LDAA ANUMB
   edef   08            TSTV5   INX
   edf0   08                    INX
   edf1   4a                    DECA
   edf2   26 fb                 BNE TSTV5
   edf4   20 f3                 BRA TSTV4
                        
   edf6   ff 01 40      TSTV6   STX DIMCAL
   edf9   bd ec ac              JSR PULLX
   edfc   bd ef fa              JSR SKIPSP
   edff   81 2c                 CMPA #','
   ee01   26 bf                 BNE TSTVER
   ee03   08                    INX
   ee04   bd ee c3              JSR EXPR
   ee07   bd ec 91              JSR PUSHX
   ee0a   bd ee 6c              JSR PULLAE
   ee0d   4d                    TSTA
   ee0e   26 c2                 BNE SUBER1
   ee10   fe 01 3e              LDX DIMPNT
   ee13   5d                    TSTB
   ee14   27 bc                 BEQ SUBER1
   ee16   e1 01                 CMPB 1,X
   ee18   22 b8                 BHI SUBER1
   ee1a   fe 01 40      TST666  LDX DIMCAL
   ee1d   08            TSTV7   INX
   ee1e   08                    INX
   ee1f   5a                    DECB
   ee20   26 fb                 BNE TSTV7
   ee22   09                    DEX
   ee23   09                    DEX
   ee24   ff 01 40              STX DIMCAL
   ee27   bd ec ac              JSR PULLX
   ee2a   bd ef fa              JSR SKIPSP
   ee2d   81 29         TSTV8   CMPA  #')'
   ee2f   26 91                 BNE TSTVER
   ee31   bd ec 91              JSR PUSHX
   ee34   b6 01 40              LDAA DIMCAL
   ee37   f6 01 41              LDAB DIMCAL+1
   ee3a   bd ec ac      TSTV9   JSR  PULLX
   ee3d   08                    INX
   ee3e   bd ee 59              JSR PUSHAE
   ee41   0c                    CLC
   ee42   39                    RTS
                        
   ee43   81 41         TSTLTR  CMPA #$41     ;Subroutine TSTLTR - Return C=0 if 'A'-'Z'
   ee45   2b 0c                 BMI NONO
   ee47   81 5a                 CMPA #$5A
   ee49   2f 0a                 BLE YESNO
   ee4b   81 30         TESTNO  CMPA #$30     ;Subroutine TESTNO - Return C=0 if '0'-'9'
   ee4d   2b 04                 BMI NONO
   ee4f   81 39                 CMPA #$39
   ee51   2f 02                 BLE YESNO
   ee53   0d            NONO    SEC
   ee54   39                    RTS
   ee55   0c            YESNO   CLC
   ee56   39                    RTS
                        
   ee57   8d 13         PULPSH  BSR PULLAE        ;PULL A & B from AESTK without removing the values
   ee59   ff 01 28      PUSHAE  STX SAVEXP        ;PUSH A & B onto AESTK (Using SP as 16bit pointer)
   ee5c   fe 01 51              LDX AESTK         ;AESTK -> X
   ee5f   e7 00                 STAB 0,X          ;Save B
   ee61   09                    DEX
   ee62   a7 00                 STAA 0,X          ;Save A
   ee64   09                    DEX
   ee65   ff 01 51              STX AESTK         ;Save new pointer to AESTK
   ee68   fe 01 28              LDX SAVEXP        ;Restore original X
   ee6b   39                    RTS
                        
   ee6c   ff 01 28      PULLAE  STX SAVEXP        ;PULL A & B from AESTK (Using SP as 16bit pointer)
   ee6f   fe 01 51              LDX AESTK         ;AESTK -> SP
   ee72   08                    INX
   ee73   a6 00                 LDAA 0,X          ;Get A
   ee75   08                    INX
   ee76   e6 00                 LDAB 0,X          ;Get B
   ee78   ff 01 51              STX AESTK         ;Save new pointer to AESTK
   ee7b   fe 01 28              LDX SAVEXP        ;Restore original X
   ee7e   39                    RTS
                        
   ee7f   bd ef fa      FACT    JSR SKIPSP
   ee82   bd ed 79              JSR TSTV
   ee85   25 04                 BCS FACT0
   ee87   bd ec d3              JSR IND
   ee8a   39                    RTS
                        
   ee8b   bd f4 00      FACT0   JSR TSTN
   ee8e   25 01                 BCS FACT1
   ee90   39                    RTS
                        
   ee91   81 28         FACT1   CMPA #'('
   ee93   26 0c                 BNE FACT2
   ee95   08                    INX
   ee96   8d 2b                 BSR  EXPR
   ee98   bd ef fa              JSR  SKIPSP
   ee9b   81 29                 CMPA #')'
   ee9d   26 02                 BNE FACT2
   ee9f   08                    INX
   eea0   39                    RTS
                        
   eea1   c6 0d         FACT2   LDAB #13
   eea3   7e f0 d0              JMP  ERROR
                        
   eea6   8d d7         TERM    BSR  FACT
   eea8   bd ef fa      TERM0   JSR SKIPSP
   eeab   81 2a                 CMPA #'*'
   eead   26 07                 BNE TERM1
   eeaf   08                    INX
   eeb0   8d cd                 BSR FACT
   eeb2   8d 41                 BSR MPY
   eeb4   20 f2                 BRA TERM0
                        
   eeb6   81 2f         TERM1   CMPA #'/'
   eeb8   26 08                 BNE TERM2
   eeba   08                    INX
   eebb   8d c2                 BSR FACT
   eebd   bd ef 4b              JSR DIV
   eec0   20 e6                 BRA TERM0
                        
   eec2   39            TERM2   RTS
                        
   eec3   bd ef fa      EXPR    JSR SKIPSP
   eec6   81 2d                 CMPA #'-'
   eec8   26 08                 BNE EXPR0
   eeca   08                    INX
   eecb   8d d9                 BSR TERM
   eecd   bd ef 96              JSR NEG
   eed0   20 07                 BRA EXPR1
   eed2   81 2b         EXPR0   CMPA #'+'
   eed4   26 01                 BNE EXPR00
   eed6   08                    INX
   eed7   8d cd         EXPR00  BSR TERM
   eed9   bd ef fa      EXPR1   JSR SKIPSP
   eedc   81 2b                 CMPA #'+'
   eede   26 08                 BNE EXPR2
   eee0   08                    INX
   eee1   8d c3                 BSR TERM
   eee3   bd ef ac              JSR ADD
   eee6   20 f1                 BRA EXPR1
   eee8   81 2d         EXPR2   CMPA #'-'
   eeea   26 08                 BNE EXPR3
   eeec   08                    INX
   eeed   8d b7                 BSR TERM
   eeef   bd ef aa              JSR SUB
   eef2   20 e5                 BRA EXPR1
   eef4   39            EXPR3   RTS
                        
   eef5   8d 32         MPY     BSR MDSIGN
   eef7   86 0f                 LDAA #15
   eef9   a7 00                 STAA 0,X
   eefb   5f                    CLRB
   eefc   4f                    CLRA
   eefd   64 03         MPY4    LSR 3,X
   eeff   66 04                 ROR 4,X
   ef01   24 0b                 BCC MPY5
   ef03   eb 02                 ADDB 2,X
   ef05   a9 01                 ADCA 1,X
   ef07   24 05                 BCC MPY5
   ef09   86 02         MPYERR  LDAA #2
   ef0b   7e f0 d0              JMP ERROR
   ef0e   68 02         MPY5    ASL 2,X
   ef10   69 01                 ROL 1,X
   ef12   6a 00                 DEC 0,X
   ef14   26 e7                 BNE MPY4
   ef16   4d                    TSTA
   ef17   2b f0                 BMI MPYERR
   ef19   7d 01 4c              TST TSIGN
   ef1c   2a 03                 BPL MPY6
   ef1e   bd ef a3              JSR NEGAB
   ef21   e7 04         MPY6    STAB 4,X
   ef23   a7 03                 STAA 3,X
   ef25   bd ec ac              JSR PULLX
   ef28   39                    RTS
                        
   ef29   bd ec 91      MDSIGN  JSR PUSHX
   ef2c   4f                    CLRA
   ef2d   fe 01 51              LDX AESTK
   ef30   6d 01                 TST 1,X
   ef32   2a 04                 BPL MDS2
   ef34   8d 60                 BSR NEG
   ef36   86 80                 LDAA #$80
   ef38   08            MDS2    INX
   ef39   08                    INX
   ef3a   ff 01 51              STX AESTK
   ef3d   6d 01                 TST 1,X
   ef3f   2a 04                 BPL MDS3
   ef41   8d 53                 BSR NEG
   ef43   8b 80                 ADDA #$80
   ef45   b7 01 4c      MDS3    STAA TSIGN
   ef48   09                    DEX
   ef49   09                    DEX
   ef4a   39                    RTS
                        
   ef4b   8d dc         DIV     BSR MDSIGN
   ef4d   6d 01                 TST 1,X
   ef4f   26 09                 BNE DIV33
   ef51   6d 02                 TST 2,X
   ef53   26 05                 BNE DIV33
   ef55   c6 08                 LDAB #8
   ef57   7e f0 d0              JMP ERROR
   ef5a   86 01         DIV33   LDAA #1
   ef5c   4c            DIV4    INCA
   ef5d   68 02                 ASL 2,X
   ef5f   69 01                 ROL 1,X
   ef61   2b 04                 BMI DIV5
   ef63   81 11                 CMPA #17
   ef65   26 f5                 BNE DIV4
   ef67   a7 00         DIV5    STAA 0,X
   ef69   a6 03                 LDAA 3,X
   ef6b   e6 04                 LDAB 4,X
   ef6d   6f 03                 CLR 3,X
   ef6f   6f 04                 CLR 4,X
   ef71   e0 02         DIV163  SUBB 2,X
   ef73   a2 01                 SBCA 1,X
   ef75   24 07                 BCC DIV165
   ef77   eb 02                 ADDB 2,X
   ef79   a9 01                 ADCA 1,X
   ef7b   0c                    CLC
   ef7c   20 01                 BRA DIV167
   ef7e   0d            DIV165  SEC
   ef7f   69 04         DIV167  ROL 4,X
   ef81   69 03                 ROL 3,X
   ef83   64 01                 LSR 1,X
   ef85   66 02                 ROR 2,X
   ef87   6a 00                 DEC 0,X
   ef89   26 e6                 BNE DIV163
   ef8b   7d 01 4c              TST TSIGN
   ef8e   2a 02                 BPL DIV169
   ef90   8d 04                 BSR NEG
   ef92   bd ec ac      DIV169  JSR PULLX
   ef95   39                    RTS
                        
   ef96   36            NEG     PSHA
   ef97   37                    PSHB
   ef98   bd ee 6c              JSR PULLAE
   ef9b   8d 06                 BSR NEGAB
   ef9d   bd ee 59              JSR PUSHAE
   efa0   33                    PULB
   efa1   32                    PULA
   efa2   39                    RTS
                        
   efa3   43            NEGAB   COMA
   efa4   53                    COMB
   efa5   cb 01                 ADDB #1
   efa7   89 00                 ADCA #0
   efa9   39                    RTS
                        
   efaa   8d ea         SUB     BSR NEG
   efac   bd ee 6c      ADD     JSR PULLAE
   efaf   f7 01 50      ADD1    STAB BNUMB
   efb2   b7 01 4f              STAA ANUMB
   efb5   bd ee 6c              JSR PULLAE
   efb8   fb 01 50              ADDB BNUMB
   efbb   b9 01 4f              ADCA ANUMB
   efbe   bd ee 59              JSR PUSHAE
   efc1   0c                    CLC
   efc2   39                    RTS
                        
   efc3   b6 01 32      FINDNO  LDAA HIGHLN
   efc6   f6 01 33              LDAB HIGHLN+1
   efc9   f0 01 31              SUBB PACKLN+1
   efcc   b2 01 30              SBCA PACKLN
   efcf   25 1e                 BCS  HIBALL
   efd1   fe 01 2e      FINDN1  LDX  SOURCE    ;X = Start of code buffer
   efd4   bd ee 57      FIND0   JSR  PULPSH    ;Save A & B
   efd7   e0 01                 SUBB 1,X
   efd9   a2 00                 SBCA 0,X
   efdb   25 15                 BCS  FIND3     ;Found A Line# > Search value
   efdd   26 03                 BNE  FIND1     ;Current Line Not = Search Value 
   efdf   5d                    TSTB           ;
   efe0   27 11                 BEQ  FIND4     ;Search line# found (return C=0) 
   efe2   08            FIND1   INX
   efe3   8d 1b         FIND2   BSR  INXSKP     ;Advance X to next non-space character
   efe5   81 1e                 CMPA #$1E       ; EOL?
   efe7   26 fa                 BNE  FIND2      ; NO = Keep looking
   efe9   08                    INX             ; Yes = Skip past it
   efea   bc 01 2a              CPX NEXTBA      ; X = NEXTBA
   efed   26 e5                 BNE FIND0       ; NO = Keep looking...
   efef   fe 01 2a      HIBALL  LDX  NEXTBA     ; X = Next Line
   eff2   0d            FIND3   SEC             ; Line# NOt Found (C=1)
   eff3   ff 01 2c      FIND4   STX WORKBA      ; Save code buffer position 
   eff6   bd ee 6c              JSR PULLAE      ; Restore A & B
   eff9   39                    RTS             ; Return
                        
   effa   a6 00         SKIPSP  LDAA 0,X         ;Get the next non-space character (advances X)
   effc   81 20                 CMPA #$20
   effe   26 03                 BNE  SKIPEX
   f000   08            INXSKP  INX              ; Point to next byte
   f001   20 f7                 BRA SKIPSP       ; Skip X past spaces
   f003   39            SKIPEX  RTS              ; Return
                        
   f004   bd f4 1c      LINENO  JSR INTSTN      ;Subroutine LINENO  
   f007   24 05                 BCC  LINE1      ;If Valid Number continue 
   f009   c6 07                 LDAB #7         ; Otherwise return ERROR #7
   f00b   7e f0 d0              JMP  ERROR
   f00e   bd ee 57      LINE1   JSR PULPSH      ;Get A & B from ASTK
   f011   b7 01 30              STAA PACKLN     ;Update PACKLN
   f014   f7 01 31              STAB PACKLN+1
   f017   ff 01 ac              STX BUFNXT      ;Update buffer pointer
   f01a   39                    RTS
                        
   f01b   fe 01 34      NXTLIN  LDX  BASPNT     ;Advance X to the start of the next BASIC line
   f01e   a6 00         NXTL12  LDAA 0,X
   f020   08                    INX
   f021   81 1e                 CMPA #$1E
   f023   26 f9                 BNE  NXTL12	   ;BNE NXTLIN			#### /DTU
   f025   ff 01 36              STX BASLIN
   f028   39                    RTS
                        
                                             ; ** SUBROUTINE CCODE lookup keyword in COMMAN table **
                                             ;*   Return with X=pointer to function execution address              
                                             ;*   If command not found then point to LET command. 
                                             ;*   Updates BUFNXT and BASPNT
                                             ;* //EMK: modified to eliminate use of SP as 16bit pointer
   f029   8d cf         CCODE   BSR SKIPSP     ; Skip X past leading spaces
   f02b   09                    DEX            ; Back up One byte
   f02c   ff 01 26              STX INDEX_4    ; Save X (points to start of non-blank input)
   f02f   ce eb 4d              LDX #COMMAN-1  ; X= Start of lookup table   
   f032   b6 01 26      LOOP3   LDAA  INDEX_4   ; SRCHPB = Keyword input Buffer pointer
   f035   b7 02 94              STAA  SRCHPA
   f038   b6 01 27              LDAA  INDEX_4+1
   f03b   b7 02 95              STAA  SRCHPA+1
   f03e   08            LOOP4   INX            ; X=X+1
   f03f   bd f8 8a              JSR   SRCHAI   ; Inc pointer and Get 1 input buffer byte -> A
   f042   e6 00                 LDAB 0,X       ; Get 1 Lookup Table byte -> B
   f044   c1 1e                 CMPB #$1E      ; EOL?
   f046   27 13                 BEQ LOOP7      ; YES = GOTO Found Keyword 
   f048   11                    CBA            ; B=A?
   f049   27 f3                 BEQ  LOOP4     ; Yes = Continue...
   f04b   08            LOOP5   INX            ; X=X+1
   f04c   8c eb ec              CPX #COMEND    ; End of Table? (Keyword Not Found)
   f04f   27 1b                 BEQ CCEXIT     ; YES = Exit using implied LET command 
   f051   e6 00                 LDAB 0,X       ; No = Continue.. Get 1 Lookup Table byte -> B
   f053   c1 1e                 CMPB #$1E      ; EOL?
   f055   26 f4                 BNE  LOOP5     ; No = Continue...
   f057   08            LOOP6   INX            ; YES = X=X+2
   f058   08                    INX
   f059   20 d7                 BRA LOOP3      ; Compare input buffer to next keyword in table..
                                
   f05b   08            LOOP7   INX            ; Keyword Found point to keyword execution address
   f05c   ff 01 28              STX SAVEXP     ; Save X
   f05f   fe 02 94              LDX SRCHPA     ; Get Buffer search index -> X
   f062   ff 01 ac              STX BUFNXT     ; X -> Next buffer search location BUFNXT
   f065   ff 01 34              STX BASPNT     ; X -> BASPNT (temp storage??)
   f068   fe 01 28              LDX SAVEXP     ; Restore X (keyword execution address)
   f06b   39            LOOP8   RTS 
                                    
                        
   f06c   ce 01 b0      CCEXIT  LDX #BUFFER    ; Keyword NOT Found.  EMK  - Command lookup failed - Reset BASPNT 
   f06f   ff 01 34              STX BASPNT     ;EMK
   f072   ce eb ac              LDX #IMPLET    ;Command lookup failed - Use LET
   f075   39                    RTS
                                               ; ***** BASIC Cold Start ***** 
   f076   fe 01 2e      START   LDX SOURCE     ;Reset pointer to start of source workspace  ($03B0)
   f079   ff 01 2a              STX NEXTBA
   f07c   ff 01 2c              STX WORKBA
   f07f   ff 01 48              STX ARRTAB
   f082   09                    DEX
   f083   4f                    CLRA
   f084   08            START2  INX            ;Fill workspace with zeros
   f085   a7 00                 STAA 0,X
   f087   bc 01 46              CPX MEMEND     ;$06FF
   f08a   26 f8                 BNE  START2
   f08c   4f            START1  CLRA           ;Reset Line# pointers & counters 
   f08d   b7 01 30              STAA PACKLN
   f090   b7 01 31              STAA PACKLN+1
   f093   b7 01 42              STAA PRCNT       ;Reset Print counter
   f096   fe 01 30              LDX PACKLN
   f099   ff 01 32              STX HIGHLN
                                
   f09c   8e 07 ff      READY   LDS #$07FF       ;WARM START HERE  *Was $7045, $D045
   f09f   ce eb ef              LDX #RDYMSG      ; Print "READY"
   f0a2   bd ec 71              JSR OUTPUT
                                                 ; ** NEWLIN ** Get a new line of input from user
   f0a5   8e 07 ff      NEWLIN  LDS #$07FF       ;Reset Stack Pointer   *Was $7045
   f0a8   ce 07 7f              LDX #$077F       ;                      *Was $707F
   f0ab   ff 01 3a              STX XSTACK       ;Reset XSTACK
   f0ae   7f 01 42              CLR PRCNT        ;Reset print counter
   f0b1   bd ec 52      NEWL3   JSR CNTLIN
   f0b4   ce 01 b0              LDX #BUFFER
   f0b7   bd ef fa              JSR SKIPSP
   f0ba   ff 01 ac              STX BUFNXT
   f0bd   bd ee 4b              JSR TESTNO
   f0c0   25 03                 BCS LOOP2
   f0c2   7e f2 00              JMP NUMBER
   f0c5   81 1e         LOOP2   CMPA #$1E
   f0c7   27 dc                 BEQ NEWLIN
   f0c9   bd f0 29              JSR CCODE      ;Lookup Command, return with X=address that holds execution address  
   f0cc   ee 00                 LDX 0,X        ;X = execution address
   f0ce   6e 00                 JMP  0,X       ;Jump to execution addtess
                        
   f0d0   8e 07 ff      ERROR   LDS #$07FF     ;Reset Stack Pointer   *Was $7045
   f0d3   bd ec 7f              JSR CRLF
   f0d6   ce eb ff              LDX #ERRMS1
   f0d9   bd ec 78              JSR OUTNCR
   f0dc   4f                    CLRA
   f0dd   bd ee 59              JSR PUSHAE
   f0e0   bd f5 19              JSR PRN
   f0e3   ce ec 07              LDX #ERRMS2
   f0e6   bd ec 78              JSR OUTNCR
   f0e9   5f                    CLRB
   f0ea   b6 01 36              LDAA BASLIN
   f0ed   81 01                 CMPA #LOCAL      ;// EMK changed due to Relocation of zero page storage: 
   f0ef   26 05                 BNE ERROR1       ;// EMK  ORG $20 -> ORG $220
   f0f1   86 00                 LDAA #$00        ;// EMK  
   f0f3   7e f0 fd              JMP ERROR2       ;// EMK
   f0f6   fe 01 36      ERROR1  LDX BASLIN
   f0f9   a6 00                 LDAA 0,X
   f0fb   e6 01                 LDAB 1,X
   f0fd   bd f5 35      ERROR2  JSR PRN0
   f100   bd ec 7f              JSR CRLF
   f103   20 97                 BRA READY
                        
   f105   fe 01 2e      RUN     LDX  SOURCE
   f108   ff 01 36              STX BASLIN
   f10b   ce 01 59              LDX #SBRSTK
   f10e   ff 01 57              STX SBRPNT
   f111   ce 01 69              LDX #FORSTK
   f114   ff 01 53              STX FORPNT
   f117   ce 07 7f              LDX #$077F            ;Was $707F
   f11a   ff 01 3a              STX XSTACK
   f11d   fe 01 2a              LDX NEXTBA
   f120   ff 01 48              STX ARRTAB
   f123   4f                    CLRA
   f124   09                    DEX
   f125   08            RUN1    INX
   f126   a7 00                 STAA 0,X
   f128   bc 01 46              CPX MEMEND
   f12b   26 f8                 BNE RUN1
   f12d   ce 02 00              LDX #VARTAB
   f130   c6 4e                 LDAB  #78
   f132   a7 00         RUN2    STAA 0,X
   f134   08                    INX
   f135   5a                    DECB
   f136   26 fa                 BNE RUN2
   f138   7e f2 fd              JMP  BASIC
                        
   f13b   ce eb fa      CLIST   LDX #PGCNTL
   f13e   bd ec 71              JSR OUTPUT
   f141   fe 01 34              LDX  BASPNT
   f144   bd ef fa      CLIST1  JSR SKIPSP
   f147   81 1e                 CMPA #$1E
   f149   27 2f                 BEQ CLIST4
   f14b   bd f4 1c              JSR INTSTN
   f14e   ff 01 34              STX BASPNT
   f151   bd ef d1              JSR FINDN1
   f154   ff 01 24              STX INDEX_3
   f157   fe 01 34              LDX BASPNT
   f15a   36                    PSHA
   f15b   bd ef fa              JSR SKIPSP
   f15e   81 1e                 CMPA #$1E
   f160   32                    PULA
   f161   26 05                 BNE CLIST2
   f163   bd ee 59              JSR PUSHAE
   f166   20 04                 BRA  CLIST3
   f168   08            CLIST2  INX
   f169   bd f4 1c              JSR  INTSTN
   f16c   4f            CLIST3  CLRA
   f16d   c6 01                 LDAB #1
   f16f   bd ef af              JSR ADD1
   f172   bd ef d1              JSR FINDN1
   f175   bd ec f9              JSR LIST0
   f178   20 03                 BRA CLIST5
   f17a   bd ec ee      CLIST4  JSR  LIST
   f17d   7e f5 c6      CLIST5  JMP  REMARK
   f180   01                    NOP
                        
   f181   bd f0 1b      PATCH   JSR   NXTLIN
   f184   ce f2 fd              LDX   #BASIC
   f187   ff 01 28              STX   SAVEXP
   f18a   0f                    SEI              ;Disable interrupts
   f18b   8e 07 ff              LDS   #$07FF     ;Set Stack Pointer (top of external RAM - 16bytes)
   f18e   7e e0 00              JMP   RESET     ;EXIT & RESTART 6800 Board (in ROM code use RESET)
                                
                                                 ;***** SYS(aaaa,A,B) ************** /EMK
   f191   bd f8 20      SYSCALL JSR   GETPRMP    ;X Points to byte after "(" 
   f194   bd f8 32              JSR   CVTADDR    ;4 Char Address to BUFFER+32 & BUFFER+33 
   f197   a6 05                 LDAA  5,X        ;X+5= v1
   f199   bd f8 72              JSR   GETVALU    ;Get 8bit Variable Value
   f19c   b7 01 d2              STAA  BUFFER+34
   f19f   a6 07                 LDAA  7,X        ;X+7= v2
   f1a1   bd f8 72              JSR   GETVALU    ;Get 8bit Variable Value
   f1a4   b7 01 d3              STAA  BUFFER+35
   f1a7   b6 01 d2              LDAA  BUFFER+34  ;Load v1      
   f1aa   f6 01 d3              LDAB  BUFFER+35  ;Load v2
   f1ad   fe 01 d0              LDX   BUFFER+32  ;X = Converted Address 
   f1b0   ad 00                 JSR   0,X        ;JSR (eg if "SYS(FBF4,A,B)" then beep should be called)
   f1b2   b7 01 d2              STAA  BUFFER+34  ;Save A Return Value
   f1b5   f7 01 d3              STAB  BUFFER+35  ;Save B Return value
   f1b8   bd f8 20              JSR   GETPRMP    ;X Points to byte after "("
   f1bb   a6 05                 LDAA  5,X        ;X+5= v1
   f1bd   f6 01 d2              LDAB  BUFFER+34
   f1c0   bd f8 7e              JSR   SETVALU    ;Set 8bit Variable Value
   f1c3   a6 07                 LDAA  7,X        ;X+7= v2
   f1c5   f6 01 d3              LDAB  BUFFER+35
   f1c8   bd f8 7e              JSR   SETVALU    ;Set 8bit Variable Value
   f1cb   bd f0 1b      SYSCALX JSR   NXTLIN     ;Process Next Statement
   f1ce   7e f2 fd              JMP   BASIC 
                                                 ;***** PEEK(aaaa,A) ************** /EMK
   f1d1   bd f8 20      DOPEEK  JSR   GETPRMP    ;X Points to byte after "("
   f1d4   bd f8 32              JSR   CVTADDR    ;4 Char Address to BUFFER+32 & BUFFER+33   
   f1d7   fe 01 d0              LDX   BUFFER+32  ;X = Converted Address
   f1da   e6 00                 LDAB  0,X        ;Get Value pointed to by aaaa ->b 
   f1dc   f7 01 d2              STAB  BUFFER+34  ;save for debugging
   f1df   bd f8 20              JSR   GETPRMP    ;X Points to byte after "("
   f1e2   a6 05                 LDAA  5,X        ;X+9=v ->A
   f1e4   bd f8 7e              JSR   SETVALU    ;Set 8bit Variable Value = B
   f1e7   7e f1 cb              JMP   SYSCALX    ;Process Next Statement
                                                 ;***** POKE(aaaa,A) ************** /EMK
   f1ea   bd f8 20      DOPOKE  JSR   GETPRMP    ;X Points to byte after "("
   f1ed   bd f8 32              JSR   CVTADDR    ;4 Char Address to BUFFER+32 & BUFFER+33  
   f1f0   a6 05                 LDAA  5,X        ;X+9=v -> A
   f1f2   bd f8 72              JSR   GETVALU    ;Get 8bit Variable Value
   f1f5   b7 01 d3              STAA  BUFFER+35  ;save for debugging
   f1f8   fe 01 d0              LDX   BUFFER+32  ;X = Converted Address
   f1fb   a7 00                 STAA  0,X        ;Store the value form v into memory at aaaa
   f1fd   7e f1 cb              JMP   SYSCALX    ;Process Next Statement
                        
   f200   bd f0 04      NUMBER  JSR LINENO       ;Validate number and update PACKLN & BUFNXT
   f203   bd ef c3      NUM1    JSR FINDNO       ;Is it an Existing Line# ?
   f206   24 16                 BCC DELREP       ; YES = Jump to DELREP
   f208   fe 01 ac              LDX BUFNXT       ;
   f20b   bd ef fa              JSR SKIPSP
   f20e   81 1e                 CMPA #$1E        ;Line# with no data following it?
   f210   27 26                 BEQ NEXIT        ; YES = Do Nothing Just exit        
   f212   fe 01 2c              LDX WORKBA
   f215   bc 01 2a              CPX NEXTBA       ;Adding A NEW LINE#
   f218   27 21                 BEQ CAPPEN       ; Yes = GOTO CAPPEN
   f21a   8d 69                 BSR INSERT       ;Otherwise ...Insert a new line
   f21c   20 1a                 BRA NEXIT        ;Print CR,LF & Exit
                                
   f21e   fe 01 ac      DELREP  LDX BUFNXT       ;Delete or Replace input line
   f221   bd ef fa              JSR SKIPSP
   f224   81 1e                 CMPA #$1E        ;Line# with no data following it?
   f226   26 0c                 BNE REPLAC       ; NO= Do Replace  YES = Do Delete
   f228   fe 01 2a              LDX NEXTBA         
   f22b   bc 01 2e              CPX SOURCE       ;If No lines entered yet, just exit
   f22e   27 08                 BEQ NEXIT        ; Otherwise DELETE
   f230   8d 13                 BSR DELETE       ;   Delete existing line
   f232   20 04                 BRA NEXIT        ;   Goto NEWLIN (input a new line) 
                        
   f234   8d 0f         REPLAC  BSR DELETE       ;Replace Existing line  (First Delete Existing line)
   f236   8d 4d                 BSR INSERT       ; Then Insert a new line
   f238   7e f0 a5      NEXIT   JMP NEWLIN       ; GOTO NEWLIN  (input a new line)
                        
   f23b   8d 48         CAPPEN  BSR INSERT       ; Insert a new Line
   f23d   fe 01 30              LDX PACKLN       ; Get PACKLN
   f240   ff 01 32              STX HIGHLN       ; Store To HIGHLN
   f243   20 f3                 BRA NEXIT        ; Goto NEWLIN (input a new line)
                                
   f245   fe 01 2a      DELETE  LDX NEXTBA      ; SUBROUTINE: Delete existing program line 
   f248   ff 02 94              STX SRCHPA      ; NEXTBA -> SRCHPA  Start of next available line storage (END of LAST Line of code) 
   f24b   fe 01 2c              LDX WORKBA      ; X = Start of line of code to DELETE
   f24e   c6 02                 LDAB #2         ; B=2
   f250   08                    INX
   f251   08                    INX             ; Skip X past Line# (X=X+2)
   f252   bd f8 a2              JSR  DECSCHA    ; 
   f255   bd f8 a2              JSR  DECSCHA    ; Decrement SRCHPA 2x 
                                                ;[This llop measures the sixe of code to move up -> B]
   f258   a6 00         DEL2    LDAA  0,X       ; A=byte from code buffer 
   f25a   bd f8 a2              JSR  DECSCHA    ; Decrement SRCHPA
   f25d   08                    INX             ; X=next byte of code
   f25e   5c                    INCB            ; B=B+1
   f25f   81 1e                 CMPA #$1E       ; EOL ? 
   f261   26 f5                 BNE DEL2        ; NO Keep Looking...
                                
   f263   fe 02 94              LDX SRCHPA      ; X = SRCHPA
   f266   ff 01 2a              STX NEXTBA      ; NEXTBA Now = Start of just deleted line 
   f269   ff 01 48              STX ARRTAB      ; ARRTAB = NEXTBA (temp storage?)
   f26c   fe 01 2c              LDX WORKBA      ; X= Start of LAST line of code  (B=Length of last line of code)
                                ;STAB DEL5+1      ;Writes B to Program Memory. Not ROM friendly
   f26f   bc 01 2a      DEL4    CPX  NEXTBA     ; Start = End?
   f272   27 10                 BEQ  DELEX      ; DONE? YES=GOTO EXIT
                                
   f274   ff 01 28              STX  SAVEXP     ;EMK  Save X
   f277   bd e8 e1              JSR  ADDB2X     ;EMK  X=B+X  (replaces ABX) (X=WORKBA + LINE LENGTH) 
   f27a   a6 00         DEL5    LDAA 0,X        ; Get Source Byte (X + B = Dest + OFFSET) 
   f27c   fe 01 28              LDX  SAVEXP     ;EMK  Restore Old X
   f27f   a7 00                 STAA 0,X        ;  Store  in Dest (X without offset)
   f281   08                    INX             ; X=X+1
   f282   20 eb                 BRA DEL4        ; Continue...
                        
   f284   39            DELEX   RTS             ; Return
                                
                                                ; ** Subroutine: Insert a line  ***
   f285   fe 01 ac      INSERT  LDX BUFNXT      ; X = KEYWORD Search location in BUFFER   
   f288   bd f0 29              JSR  CCODE      ;Lookup Connamd, returns X=address of pointer to execution address
   f28b   ff 01 4a      INS1    STX  KEYWD      ;KEYWD = Result of call to CCODE  (pointer to execution address)
   f28e   f6 01 af              LDAB ENDBUF+1   ; B= End of Input Buffer
   f291   f0 01 ad              SUBB BUFNXT+1   ; Subtract pointer to byte after keyword
   f294   cb 04                 ADDB #$04       ; Add 4 bytes to accomodate Line#, token and EOL
                                ;STAB OFFSET+1         ;Writes B to Program Memory. Not ROM friendly
   f296   f7 01 22              STAB INDEX_2    ;EMK   Save B  (Size of parameter data +4) 
   f299   0c                    CLC                    
   f29a   fb 01 2b              ADDB NEXTBA+1      ;Add NEXTBA (low) to B (Size of parameter data +4)
   f29d   86 00                 LDAA #$00
   f29f   b9 01 2a              ADCA NEXTBA        ;A= High Byte of NEXTBA adjusted for carry
   f2a2   b1 01 46              CMPA MEMEND        ;OUT of MEMORY?
   f2a5   22 51                 BHI  OVERFL        ;ERROR #14
   f2a7   f7 01 2b              STAB NEXTBA+1      ; Otherwise Save B-> NEXTBA (low byte)
   f2aa   b7 01 2a              STAA NEXTBA        ;           Save A-> NEXTBA (high byte)
   f2ad   fe 01 2a              LDX  NEXTBA        ; X = Next Line Storage Location
   f2b0   ff 01 48              STX  ARRTAB        ; ARRTAB =  Next Line Storage Location (temp save??)
   f2b3   bc 01 2c      INS2    CPX  WORKBA       ;Done?   
   f2b6   27 19                 BEQ BUFWRT        ;YES = Write Buffer to code storage
   f2b8   09                    DEX               ;NO X=X-1  
   f2b9   a6 00                 LDAA 0,X          ;Get Source Byte 
   f2bb   ff 01 20              STX  INDEX_1        ;EMK     Save X
   f2be   f7 02 90              STAB INDEX_6        ;EMK     Save B
   f2c1   f6 01 22              LDAB INDEX_2        ;EMK     B = Saved B
   f2c4   bd e8 e1              JSR  ADDB2X         ;EMK     X=X+B  Replaces ABX
   f2c7   a7 00         OFFSET  STAA 0,X          ;Store in destination
   f2c9   fe 01 20              LDX  INDEX_1        ;EMK     Restore X
   f2cc   f6 02 90              LDAB INDEX_6        ;EMK     Restore B
   f2cf   20 e2                 BRA  INS2        ; Loop until X=WORKBA..
                                
   f2d1   fe 01 ac      BUFWRT  LDX  BUFNXT      ; GET BUFNXT (Input buffer pointer)
   f2d4   09                    DEX              ; Back up 1 (we will increment in call to SRCHAI)
   f2d5   ff 02 94              STX  SRCHPA      ; BUFNXT-1 -> SRCHPA
   f2d8   fe 01 2c              LDX  WORKBA      ; X= Next Available storage location
   f2db   b6 01 30              LDAA PACKLN      ;A = Line# (high)
   f2de   a7 00                 STAA 0,X         ;Store
   f2e0   08                    INX
   f2e1   b6 01 31              LDAA PACKLN+1    ;A= Line# (low)
   f2e4   a7 00                 STAA 0,X         ;Store
   f2e6   08                    INX
   f2e7   b6 01 4b              LDAA KEYWD+1     ;A= TOKEN
   f2ea   a7 00                 STAA 0,X         ;Store
   f2ec   08                    INX
   f2ed   bd f8 8a      BUF3    JSR  SRCHAI      ;Increment pointer and Get input data
   f2f0   a7 00                 STAA 0,X         ;Store in code buffer
   f2f2   08                    INX
   f2f3   81 1e                 CMPA #$1E        ;EOL?
   f2f5   26 f6                 BNE BUF3         ;NO = Continue
   f2f7   39                    RTS              ;Exit
                        
   f2f8   c6 0e         OVERFL  LDAB #14         ;OUT of Memory Error
   f2fa   7e f0 d0              JMP ERROR
                                
                                                 ;SUBROUTINE: Execute a BASIC Statement
   f2fd   fe 01 36      BASIC   LDX BASLIN       
   f300   bc 01 2a              CPX NEXTBA       ;Last Line of code?
   f303   26 03                 BNE BASIC1       ;NO = Process It
   f305   7e f0 9c      BASIC0  JMP READY        ;Otherwise Print Ready and pronpt for more input...
                        
   f308   b6 01 36      BASIC1  LDAA BASLIN      ; TST BASLIN  //EMK This change due to relocation: ORG $20 -> ORG $220
   f30b   81 01                 CMPA #LOCAL      ; // EMK If local variables are moved to a different page this must change as well
   f30d   27 f6                 BEQ BASIC0       ; Processed last line so just print "Ready"
   f30f   08                    INX              ; Otherwise...
   f310   08                    INX              ; Step past Line#
   f311   a6 00                 LDAA 0,X         ; Get keyword token
   f313   08                    INX
   f314   ff 01 34              STX  BASPNT      ;BASPNT=byte after keyword token
   f317   ce eb 4e              LDX #COMMAN      ;X= Address of COMMAND lookup table
   f31a   ff 01 4a              STX KEYWD        ;KEYWD + KEYWD+1 = X
   f31d   b7 01 4b              STAA KEYWD+1     ;Change low KEYWD address = token
   f320   ce 02 8c              LDX #ASTACK      
   f323   ff 01 51              STX AESTK
   f326   fe 01 4a              LDX KEYWD        ;X=address of keyword in lookup table 
   f329   ee 00                 LDX 0,X          ;X=address of keyword routine
   f32b   6e 00         BASIC2  JMP 0,X          ;Jump to keyword routine
                        
   f32d   fe 01 36      GOSUB   LDX BASLIN
   f330   ff 01 20              STX INDEX_1
   f333   bd f0 1b              JSR NXTLIN
   f336   fe 01 57              LDX SBRPNT
   f339   8c 01 69              CPX #SBRSTK+16
   f33c   26 05                 BNE  GOSUB1
   f33e   c6 09                 LDAB #9
   f340   7e f0 d0              JMP  ERROR
   f343   b6 01 36      GOSUB1  LDAA BASLIN
   f346   a7 00                 STAA 0,X
   f348   08                    INX
   f349   b6 01 37              LDAA BASLIN+1
   f34c   a7 00                 STAA 0,X
   f34e   08                    INX
   f34f   ff 01 57              STX SBRPNT
   f352   fe 01 20              LDX INDEX_1
   f355   ff 01 36              STX BASLIN
   f358   fe 01 34      GOTO    LDX BASPNT
   f35b   bd ee c3              JSR EXPR
   f35e   bd ef d1              JSR FINDN1
   f361   24 05                 BCC GOTO2
   f363   c6 07                 LDAB #7
   f365   7e f0 d0              JMP  ERROR
   f368   ff 01 36      GOTO2   STX BASLIN
   f36b   20 90                 BRA  BASIC
                        
   f36d   fe 01 57      RETURN  LDX  SBRPNT
   f370   8c 01 59              CPX #SBRSTK
   f373   26 05                 BNE RETUR1
   f375   c6 0a                 LDAB #10
   f377   7e f0 d0              JMP  ERROR
   f37a   09            RETUR1  DEX
   f37b   09                    DEX
   f37c   ff 01 57              STX SBRPNT
   f37f   ee 00                 LDX  0,X
   f381   ff 01 36              STX BASLIN
   f384   7e f2 fd              JMP BASIC
                        
   f387   ce eb e3      PAUSE   LDX  #PAUMSG
   f38a   bd ec 78              JSR OUTNCR
   f38d   bd ed 3e              JSR PRINSP
   f390   fe 01 36              LDX  BASLIN
   f393   a6 00                 LDAA 0,X
   f395   08                    INX
   f396   e6 00                 LDAB 0,X
   f398   08                    INX
   f399   bd f5 35              JSR  PRN0
   f39c   bd ec 69      PAUSE1  JSR  INCH
   f39f   81 0d                 CMPA #$0D
   f3a1   26 f9                 BNE  PAUSE1
   f3a3   bd ec 7f              JSR  CRLF
   f3a6   7e f5 c6      PAUSE2  JMP  REMARK
   f3a9   b6 01 34      INPUT   LDAA  BASPNT
   f3ac   26 04                 BNE INPUT0
   f3ae   c6 0c                 LDAB #12
   f3b0   20 24                 BRA INPERR
   f3b2   bd ec 11      INPUT0  JSR KEYBD
   f3b5   ce 01 b0              LDX  #BUFFER
   f3b8   ff 01 ac              STX BUFNXT
   f3bb   fe 01 34              LDX BASPNT
   f3be   bd ed 79      INPUT1  JSR TSTV
   f3c1   25 30                 BCS INPEX
   f3c3   ff 01 34              STX BASPNT
   f3c6   fe 01 ac              LDX BUFNXT
   f3c9   8d 45         INPUT2  BSR  INNUM
   f3cb   24 14                 BCC INPUT4
   f3cd   09                    DEX
   f3ce   a6 00                 LDAA 0,X
   f3d0   81 1e                 CMPA #$1E
   f3d2   27 05                 BEQ INPUTS
   f3d4   c6 02                 LDAB #2
   f3d6   7e f0 d0      INPERR  JMP  ERROR
   f3d9   bd ec 11      INPUTS  JSR  KEYBD
   f3dc   ce 01 b0              LDX #BUFFER
   f3df   20 e8                 BRA INPUT2
   f3e1   bd ec b8      INPUT4  JSR  STORE
   f3e4   08                    INX
   f3e5   ff 01 ac              STX BUFNXT
   f3e8   fe 01 34              LDX BASPNT
   f3eb   bd ef fa              JSR SKIPSP
   f3ee   08                    INX
   f3ef   81 2c                 CMPA #','
   f3f1   27 cb                 BEQ INPUT1
   f3f3   09            INPEX   DEX
   f3f4   7f 01 42              CLR PRCNT
   f3f7   81 1e                 CMPA #$1E
   f3f9   27 ab                 BEQ PAUSE2
   f3fb   c6 03         DBLLTR  LDAB #3
   f3fd   7e f0 d0              JMP  ERROR
   f400   8d 1a         TSTN    BSR INTSTN
   f402   25 06                 BCS TSTN0
   f404   bd ee 6c              JSR PULLAE
   f407   4d                    TSTA
   f408   2a 02                 BPL TSTN1
   f40a   0d            TSTN0   SEC
   f40b   39                    RTS
   f40c   bd ee 59      TSTN1   JSR  PUSHAE
   f40f   39                    RTS
                        
   f410   bd ef fa      INNUM   JSR  SKIPSP
   f413   b7 01 4c              STAA TSIGN
   f416   08                    INX
   f417   81 2d                 CMPA #'-'
   f419   27 04                 BEQ  INNUM0
   f41b   09                    DEX
   f41c   7f 01 4c      INTSTN  CLR  TSIGN          ;Subroutine INTSTN - 
   f41f   bd ef fa      INNUM0  JSR   SKIPSP        ;Skip past spaces - X points to non-space
   f422   bd ee 4b              JSR TESTNO          ;C=0 if '0'-'9'
   f425   24 01                 BCC INNUM1          ;IF NOT Number the return
   f427   39                    RTS
   f428   09            INNUM1  DEX                 ;Back up 1 byte
   f429   4f                    CLRA                ;A=0
   f42a   5f                    CLRB                ;B=0
   f42b   08            INNUM2  INX                 ;Forward 1 byte
   f42c   36                    PSHA                ;Save A
   f42d   a6 00                 LDAA 0,X            ;Get Byte
   f42f   bd ee 4b              JSR TESTNO          ;C=0 if '0'-'9'
   f432   25 2f                 BCS INNEX           ;If NOT Number then exit
   f434   80 30                 SUBA #$30
   f436   b7 01 4e              STAA TNUMB          ;Save digit value in TNUMB
   f439   32                    PULA                ;Restore A
   f43a   58                    ASLB                ;B <<
   f43b   49                    ROLA                ;A <<
   f43c   25 20                 BCS INNERR          ;If C got set ERROR 2 
   f43e   f7 01 50              STAB BNUMB
   f441   b7 01 4f              STAA ANUMB
   f444   58                    ASLB
   f445   49                    ROLA
   f446   25 16                 BCS INNERR
   f448   58                    ASLB
   f449   49                    ROLA
   f44a   25 12                 BCS INNERR
   f44c   fb 01 50              ADDB BNUMB
   f44f   b9 01 4f              ADCA ANUMB
   f452   25 0a                 BCS INNERR
   f454   fb 01 4e              ADDB TNUMB
   f457   89 00                 ADCA #0
   f459   25 03                 BCS  INNERR
   f45b   7e f4 2b              JMP  INNUM2
   f45e   c6 02         INNERR  LDAB #2             ;Return ERROR #2
   f460   7e f0 d0              JMP  ERROR
   f463   32            INNEX   PULA
   f464   7d 01 4c              TST TSIGN
   f467   27 03                 BEQ INNEX2
   f469   bd ef a3              JSR NEGAB
   f46c   bd ee 59      INNEX2  JSR PUSHAE
   f46f   0c                    CLC
   f470   39                    RTS
                        
   f471   fe 01 34      PRINT   LDX  BASPNT
   f474   bd ef fa      PRINT0  JSR  SKIPSP
   f477   81 22                 CMPA #'"'
   f479   26 18                 BNE PRINT4
   f47b   08                    INX
   f47c   a6 00         PRINT1  LDAA 0,X
   f47e   08                    INX
   f47f   81 22                 CMPA  #'"'
   f481   27 5c                 BEQ  PRIN88
   f483   81 1e                 CMPA #$1E
   f485   26 04                 BNE PRINT2
   f487   c6 04                 LDAB  #4
   f489   20 35                 BRA  PRINTE
   f48b   bd ec 63      PRINT2  JSR  OUTCH
   f48e   bd f5 07              JSR ENLINE
   f491   20 e9                 BRA PRINT1
   f493   81 1e         PRINT4  CMPA #$1E
   f495   26 15                 BNE PRINT6
   f497   09                    DEX
   f498   a6 00                 LDAA 0,X
   f49a   08                    INX
   f49b   81 3b                 CMPA #';'
   f49d   27 06                 BEQ PRINT5
   f49f   bd ec 7f              JSR CRLF
   f4a2   7f 01 42              CLR PRCNT
   f4a5   08            PRINT5  INX
   f4a6   ff 01 36              STX BASLIN
   f4a9   7e f2 fd              JMP BASIC
   f4ac   81 54         PRINT6  CMPA #'T'
   f4ae   26 29                 BNE PRINT8
   f4b0   e6 01                 LDAB 1,X
   f4b2   c1 41                 CMPB #'A'
   f4b4   26 23                 BNE PRINT8
   f4b6   08                    INX
   f4b7   08                    INX
   f4b8   a6 00                 LDAA 0,X
   f4ba   81 42                 CMPA #'B'
   f4bc   27 05                 BEQ PRINT7
   f4be   c6 0b                 LDAB #11
   f4c0   7e f0 d0      PRINTE  JMP  ERROR
   f4c3   08            PRINT7  INX
   f4c4   bd ee c3              JSR EXPR
   f4c7   bd ee 6c              JSR PULLAE
   f4ca   f0 01 42              SUBB PRCNT
   f4cd   23 10                 BLS PRIN88
   f4cf   bd ed 3e      PRIN77  JSR PRINSP
   f4d2   8d 33                 BSR ENLINE
   f4d4   5a                    DECB
   f4d5   26 f8                 BNE PRIN77
   f4d7   20 06                 BRA PRIN88
   f4d9   bd ee c3      PRINT8  JSR  EXPR
   f4dc   bd f5 19              JSR  PRN
   f4df   bd ef fa      PRIN88  JSR  SKIPSP
   f4e2   81 2c                 CMPA #','
   f4e4   26 11                 BNE PRIN99
   f4e6   08                    INX
   f4e7   b6 01 42      PRLOOP  LDAA PRCNT
   f4ea   16                    TAB
   f4eb   c4 f8                 ANDB #$F8
   f4ed   10                    SBA
   f4ee   27 0c                 BEQ PRI999
   f4f0   bd ed 3e              JSR PRINSP
   f4f3   8d 12                 BSR ENLINE
   f4f5   20 f0                 BRA PRLOOP
   f4f7   81 3b         PRIN99  CMPA #';'
   f4f9   26 04                 BNE PREND
   f4fb   08                    INX
   f4fc   7e f4 74      PRI999  JMP  PRINT0
   f4ff   81 1e         PREND   CMPA #$1E
   f501   27 90                 BEQ PRINT4
   f503   c6 06                 LDAB #6
   f505   20 b9                 BRA PRINTE
   f507   36            ENLINE  PSHA
   f508   b6 01 42              LDAA PRCNT
   f50b   4c                    INCA
   f50c   81 72                 CMPA #MAXLIN
   f50e   26 04                 BNE ENLEXT
   f510   bd ec 7f              JSR CRLF
   f513   4f                    CLRA
   f514   b7 01 42      ENLEXT  STAA PRCNT
   f517   32                    PULA
   f518   39                    RTS
   f519   bd ed 3e      PRN     JSR PRINSP
   f51c   8d e9                 BSR ENLINE
   f51e   86 ff                 LDAA #$FF
   f520   b7 01 4c              STAA TSIGN
   f523   bd ee 6c              JSR PULLAE
   f526   4d                    TSTA
   f527   2a 0c                 BPL PRN0
   f529   bd ef a3              JSR NEGAB
   f52c   36                    PSHA
   f52d   86 2d                 LDAA #'-'
   f52f   bd ec 63              JSR OUTCH
   f532   8d d3                 BSR ENLINE
   f534   32                    PULA
   f535   bd ec 91      PRN0    JSR  PUSHX
   f538   ce f5 73              LDX #KIOK
   f53b   7f 01 4e      PRN1    CLR  TNUMB
   f53e   e0 01         PRN2    SUBB 1,X
   f540   a2 00                 SBCA 0,X
   f542   25 05                 BCS PRN5
   f544   7c 01 4e              INC TNUMB
   f547   20 f5                 BRA PRN2
   f549   eb 01         PRN5    ADDB 1,X
   f54b   a9 00                 ADCA 0,X
   f54d   36                    PSHA
   f54e   b6 01 4e              LDAA TNUMB
   f551   26 0a                 BNE PRN6
   f553   8c f5 7b              CPX #KIOK+8
   f556   27 05                 BEQ PRN6
   f558   7d 01 4c              TST TSIGN
   f55b   26 0a                 BNE PRN7
   f55d   8b 30         PRN6    ADDA #$30
   f55f   7f 01 4c              CLR TSIGN
   f562   bd ec 63              JSR OUTCH
   f565   8d a0                 BSR ENLINE
   f567   32            PRN7    PULA
   f568   08                    INX
   f569   08                    INX
   f56a   8c f5 7d              CPX #KIOK+10
   f56d   26 cc                 BNE PRN1
   f56f   bd ec ac              JSR PULLX
   f572   39                    RTS
                        
   f573   27 10         KIOK    FDB 10000
   f575   03 e8                 FDB 1000
   f577   00 64                 FDB 100
   f579   00 0a                 FDB 10
   f57b   00 01                 FDB 1
                        
   f57d   fe 01 34      LET     LDX BASPNT
   f580   bd ed 79              JSR TSTV
   f583   24 05                 BCC LET1
   f585   c6 0c         LET0    LDAB #12
   f587   7e f0 d0      LET00   JMP  ERROR
   f58a   bd ef fa      LET1    JSR  SKIPSP
   f58d   08                    INX
   f58e   81 3d                 CMPA #'='
   f590   27 04                 BEQ LET3
   f592   c6 06         LET2    LDAB #6
   f594   20 f1                 BRA LET00
   f596   bd ee c3      LET3    JSR EXPR
   f599   81 1e                 CMPA #$1E
   f59b   26 f5                 BNE LET2
   f59d   bd ec b8              JSR STORE
   f5a0   20 24                 BRA REMARK
   f5a2   f6 01 49      SIZE    LDAB ARRTAB+1
   f5a5   b6 01 48              LDAA ARRTAB
   f5a8   f0 01 2f              SUBB SOURCE+1
   f5ab   b2 01 2e              SBCA SOURCE
   f5ae   bd f5 35              JSR PRN0
   f5b1   bd ed 3e              JSR PRINSP
   f5b4   f6 01 47              LDAB MEMEND+1
   f5b7   b6 01 46              LDAA MEMEND
   f5ba   f0 01 49              SUBB ARRTAB+1
   f5bd   b2 01 48              SBCA ARRTAB
   f5c0   bd f5 35              JSR PRN0
   f5c3   bd ec 7f              JSR CRLF
   f5c6   bd f0 1b      REMARK  JSR NXTLIN
   f5c9   7e f2 fd              JMP BASIC
   f5cc   fe 01 34      DIM     LDX BASPNT
   f5cf   bd ef fa      DIM1    JSR SKIPSP
   f5d2   bd ee 43              JSR TSTLTR
   f5d5   24 03                 BCC DIM111
   f5d7   7e f6 79              JMP DIMEX
   f5da   80 40         DIM111  SUBA #$40
   f5dc   b7 01 9a              STAA DIMVAR+1
   f5df   48                    ASLA
   f5e0   bb 01 9a              ADDA DIMVAR+1
   f5e3   b7 01 9a              STAA DIMVAR+1
   f5e6   bd ec 91              JSR PUSHX
   f5e9   fe 01 99              LDX DIMVAR
   f5ec   6d 00                 TST 0,X
   f5ee   26 1e                 BNE DIMERR
   f5f0   6d 01                 TST 1,X
   f5f2   26 1a                 BNE DIMERR
   f5f4   6d 02                 TST 2,X
   f5f6   26 16                 BNE DIMERR
   f5f8   b6 01 49              LDAA ARRTAB+1
   f5fb   a7 01                 STAA 1,X
   f5fd   b6 01 48              LDAA ARRTAB
   f600   a7 00                 STAA 0,X
   f602   a7 02                 STAA 2,X
   f604   bd ec ac              JSR PULLX
   f607   bd f0 00              JSR INXSKP
   f60a   81 28                 CMPA #'('
   f60c   27 05                 BEQ  DIM2
   f60e   c6 05         DIMERR  LDAB #5
   f610   7e f0 d0      DIMER1  JMP ERROR
   f613   08            DIM2    INX
   f614   bd ee c3              JSR EXPR
   f617   bd ee 57              JSR PULPSH
   f61a   5d                    TSTB
   f61b   27 03                 BEQ SUBERR
   f61d   4d                    TSTA
   f61e   27 04                 BEQ  DIM3
   f620   c6 0f         SUBERR  LDAB #15
   f622   20 ec                 BRA DIMER1
   f624   8d 5a         DIM3    BSR STRSUB
   f626   a6 00                 LDAA 0,X
   f628   81 2c                 CMPA #','
   f62a   26 12                 BNE DIM6
   f62c   08                    INX
   f62d   bd ee c3              JSR EXPR
   f630   bd ee 57              JSR PULPSH
   f633   5d                    TSTB
   f634   27 ea                 BEQ SUBERR
   f636   4d                    TSTA
   f637   26 e7                 BNE SUBERR
   f639   8d 45                 BSR STRSUB
   f63b   bd ee f5              JSR MPY
   f63e   4f            DIM6    CLRA
   f63f   c6 02                 LDAB #2
   f641   bd ee 59              JSR PUSHAE
   f644   bd ee f5              JSR MPY
   f647   a6 00                 LDAA 0,X
   f649   81 29                 CMPA #')'
   f64b   26 c1                 BNE DIMERR
   f64d   08                    INX
   f64e   f6 01 49              LDAB ARRTAB+1
   f651   b6 01 48              LDAA ARRTAB
   f654   bd ef af              JSR ADD1
   f657   4f                    CLRA
   f658   c6 02                 LDAB #2
   f65a   bd ef af              JSR ADD1
   f65d   bd ee 6c              JSR PULLAE
   f660   b1 01 46              CMPA MEMEND
   f663   23 03                 BLS DIM7
   f665   7e f2 f8              JMP OVERFL
   f668   b7 01 48      DIM7    STAA ARRTAB
   f66b   f7 01 49              STAB ARRTAB+1
   f66e   bd ef fa              JSR SKIPSP
   f671   81 2c                 CMPA #','
   f673   26 04                 BNE DIMEX
   f675   08                    INX
   f676   7e f5 cf              JMP DIM1
   f679   81 1e         DIMEX   CMPA #$1E
   f67b   26 91                 BNE DIMERR
   f67d   7e f5 c6              JMP REMARK
   f680   bd ec 91      STRSUB  JSR PUSHX
   f683   fe 01 99              LDX DIMVAR
   f686   ee 00                 LDX 0,X
   f688   6d 00         STRSU2  TST 0,X
   f68a   27 03                 BEQ STRSU3
   f68c   08                    INX
   f68d   20 f9                 BRA STRSU2
   f68f   e7 00         STRSU3  STAB 0,X
   f691   bd ec ac              JSR PULLX
   f694   39                    RTS
                        
   f695   fe 01 34      FOR     LDX  BASPNT
   f698   bd ed 79              JSR TSTV
   f69b   24 03                 BCC FOR1
   f69d   7e f5 85              JMP LET0
   f6a0   ff 01 34      FOR1    STX BASPNT
   f6a3   bd ee 57              JSR PULPSH
   f6a6   fe 01 53              LDX FORPNT
   f6a9   8c 01 99              CPX #FORSTK+48
   f6ac   26 05                 BNE FOR11
   f6ae   c6 10                 LDAB #16
   f6b0   7e f0 d0              JMP ERROR
   f6b3   a7 00         FOR11   STAA 0,X
   f6b5   08                    INX
   f6b6   e7 00                 STAB 0,X
   f6b8   08                    INX
   f6b9   ff 01 53              STX FORPNT
   f6bc   fe 01 34              LDX BASPNT
   f6bf   bd ef fa              JSR SKIPSP
   f6c2   08                    INX
   f6c3   81 3d                 CMPA #'='
   f6c5   27 03                 BEQ  FOR3
   f6c7   7e f5 92      FOR2    JMP  LET2
   f6ca   bd ee c3      FOR3    JSR EXPR
   f6cd   bd ec b8              JSR STORE
   f6d0   08                    INX
   f6d1   81 54                 CMPA #'T'
   f6d3   26 f2                 BNE FOR2
   f6d5   a6 00                 LDAA 0,X
   f6d7   08                    INX
   f6d8   81 4f                 CMPA #'O'
   f6da   26 eb                 BNE FOR2
   f6dc   bd ee c3              JSR EXPR
   f6df   bd ee 6c              JSR PULLAE
   f6e2   ff 01 34              STX BASPNT
   f6e5   fe 01 53              LDX FORPNT
   f6e8   a7 00                 STAA 0,X
   f6ea   08                    INX
   f6eb   e7 00                 STAB 0,X
   f6ed   08                    INX
   f6ee   ff 01 53              STX FORPNT
   f6f1   fe 01 34              LDX BASPNT
   f6f4   a6 00                 LDAA 0,X
   f6f6   81 1e                 CMPA #$1E
   f6f8   26 cd         FOR8    BNE FOR2
   f6fa   08                    INX
   f6fb   ff 01 36              STX BASLIN
   f6fe   fe 01 53              LDX FORPNT
   f701   b6 01 36              LDAA BASLIN
   f704   a7 00                 STAA 0,X
   f706   08                    INX
   f707   f6 01 37              LDAB BASLIN+1
   f70a   e7 00                 STAB 0,X
   f70c   08                    INX
   f70d   ff 01 53              STX FORPNT
   f710   7e f2 fd              JMP BASIC
                        
   f713   fe 01 34      NEXT    LDX BASPNT
   f716   bd ed 79              JSR TSTV
   f719   24 03                 BCC NEXT1
   f71b   7e f5 85              JMP LET0
   f71e   bd ef fa      NEXT1   JSR SKIPSP
   f721   81 1e                 CMPA #$1E
   f723   26 d3                 BNE FOR8
   f725   08                    INX
   f726   ff 01 36              STX  BASLIN
   f729   ce 01 69              LDX #FORSTK
   f72c   bd ee 57              JSR PULPSH
   f72f   bc 01 53      NEXT2   CPX FORPNT
   f732   27 3c                 BEQ NEXT6
   f734   a1 00                 CMPA 0,X
   f736   26 30                 BNE NEXT5
   f738   e1 01                 CMPB 1,X
   f73a   26 2c                 BNE NEXT5
   f73c   bd ec d3              JSR IND
   f73f   bd ee 57              JSR PULPSH
   f742   e0 03                 SUBB 3,X
   f744   a2 02                 SBCA 2,X
   f746   25 06                 BCS NEXT4
   f748   ff 01 53              STX  FORPNT
   f74b   7e f2 fd      NEXT3   JMP  BASIC
   f74e   bd ee 6c      NEXT4   JSR PULLAE
   f751   cb 01                 ADDB #1
   f753   89 00                 ADCA #0
   f755   bd ec 91              JSR PUSHX
   f758   ee 00                 LDX 0,X
   f75a   a7 00                 STAA 0,X
   f75c   e7 01                 STAB 1,X
   f75e   bd ec ac              JSR PULLX
   f761   ee 04                 LDX 4,X
   f763   ff 01 36              STX BASLIN
   f766   20 e3                 BRA  NEXT3
   f768   08            NEXT5   INX
   f769   08                    INX
   f76a   08                    INX
   f76b   08                    INX
   f76c   08                    INX
   f76d   08                    INX
   f76e   20 bf                 BRA NEXT2
   f770   c6 11         NEXT6   LDAB #17 
   f772   7e f0 d0              JMP ERROR
                        
   f775   fe 01 34      IF      LDX BASPNT
   f778   bd ee c3              JSR EXPR
   f77b   8d 1a                 BSR RELOP
   f77d   b7 01 4d              STAA NCMPR
   f780   bd ee c3              JSR EXPR
   f783   ff 01 34              STX BASPNT
   f786   8d 4b                 BSR CMPR
   f788   24 03                 BCC IF2
   f78a   7e f5 c6              JMP  REMARK
   f78d   fe 01 34      IF2     LDX  BASPNT
   f790   bd f0 29              JSR  CCODE
   f793   ee 00                 LDX 0,X
   f795   6e 00                 JMP 0,X
   f797   bd ef fa      RELOP   JSR SKIPSP
   f79a   08                    INX
   f79b   81 3d                 CMPA #'='
   f79d   26 03                 BNE RELOP0
   f79f   86 00                 LDAA #0
   f7a1   39                    RTS
   f7a2   e6 00         RELOP0  LDAB 0,X
   f7a4   81 3c                 CMPA #'<'
   f7a6   26 13                 BNE RELOP4
   f7a8   c1 3d                 CMPB #'='
   f7aa   26 04                 BNE RELOP1
   f7ac   08                    INX
   f7ad   86 02                 LDAA #2
   f7af   39                    RTS
   f7b0   c1 3e         RELOP1  CMPB #'>'
   f7b2   26 04                 BNE RELOP3
   f7b4   08            RELOP2  INX
   f7b5   86 03                 LDAA #3
   f7b7   39                    RTS
   f7b8   86 01         RELOP3  LDAA #1
   f7ba   39                    RTS
   f7bb   81 3e         RELOP4  CMPA #'>'
   f7bd   27 05                 BEQ REL44
   f7bf   c6 06                 LDAB #6
   f7c1   7e f0 d0              JMP ERROR
   f7c4   c1 3d         REL44   CMPB  #'='
   f7c6   26 04                 BNE RELOP5
   f7c8   08                    INX
   f7c9   86 05                 LDAA #5
   f7cb   39                    RTS
   f7cc   c1 3c         RELOP5  CMPB #'<'
   f7ce   27 e4                 BEQ RELOP2
   f7d0   86 04                 LDAA #4
   f7d2   39                    RTS
                        
   f7d3   b6 01 4d      CMPR    LDAA  NCMPR
   f7d6   48                    ASLA
   f7d7   48                    ASLA
   f7d8   37                    PSHB
   f7d9   16                    TAB
   f7da   ce f7 ea              LDX #CMPR1
   f7dd   bd e8 e1              JSR ADDB2X      ;(replaces ABX)
   f7e0   33                    PULB
   f7e1   bd ef aa              JSR SUB
   f7e4   bd ee 6c              JSR PULLAE
   f7e7   4d                    TSTA
   f7e8   6e 00         FUNNY   JMP  0,X
   f7ea   27 18         CMPR1   BEQ MAYEQ
   f7ec   20 12                 BRA NOCMPR
   f7ee   2b 12                 BMI OKCMPR
   f7f0   20 0e                 BRA NOCMPR
   f7f2   2b 0e                 BMI OKCMPR
   f7f4   20 f4                 BRA CMPR1
   f7f6   26 0a                 BNE OKCMPR
   f7f8   20 0f                 BRA MYNTEQ
   f7fa   27 0d                 BEQ MYNTEQ
   f7fc   2b 02                 BMI NOCMPR
   f7fe   2a 02                 BPL OKCMPR
   f800   0d            NOCMPR  SEC
   f801   39                    RTS
   f802   0c            OKCMPR  CLC
   f803   39                    RTS
   f804   5d            MAYEQ   TSTB
   f805   27 fb                 BEQ OKCMPR
   f807   20 f7                 BRA NOCMPR
   f809   5d            MYNTEQ  TSTB
   f80a   26 f6                 BNE OKCMPR
   f80c   20 f2                 BRA NOCMPR
                        
                        ;******************************
                        ;* REPLACEMENT FOR BREAK ROUTINE /EMK
                        ;CHKBRK	RTS
   f80e   36            CHKBRK	PSHA
   f80f   bd e2 7a              JSR   TESTKEY
   f812   26 0a         	      BNE	  CHKNBRK
   f814   bd e2 81              JSR   GETBYTE 
   f817   81 1b         	      CMPA	#CANCEL		;IS CHARACTER AN ESCAPE?
   f819   26 03         	      BNE	  CHKNBRK
   f81b   7e f0 9c      	      JMP	  READY		  ;BREAK. GOTO PROMPT
   f81e   32            CHKNBRK	PULA	          ;NO BREAK. CONTINUE
   f81f   39            	      RTS
                        
                        ;***************************************************************
                        ; GETPRMP  
                        ; Set X= 2nd Byte after Keyword or Keyword token (parm data)
                        ;***************************************************************
   f820   fe 01 34      GETPRMP LDX   BASPNT     ;X Points to end of keyword: (aaaa,v,v) in BUFFER  
   f823   b6 01 34              LDAA  BASPNT
   f826   81 01                 CMPA  #LOCAL     ;If BASPNT=$02 then executing command directly
   f828   27 06                 BEQ   GETPRM1    ;Otherwise executing from stored source code
   f82a   fe 01 36              LDX   BASLIN     ;X Points to statement: nnt(aaaa,v,v) in SOURCE
   f82d   08                    INX
   f82e   08                    INX
   f82f   08                    INX
   f830   08            GETPRM1 INX              ;If exexuting directly just INC past the "(" 
   f831   39                    RTS
                        
                        ;***************************************************************
                        ;* CVTADDR  
                        ; Convert 4 ASCII Hex Chrs at X=4 to 2 Bytes in BUFFER+32 & BUFFER+33
                        ;***************************************************************
   f832   a6 00         CVTADDR LDAA  0,X        ;X=Address char1
   f834   bd e3 36              JSR   CHR2VAL    ;Convert to HEX
   f837   48                    LSLA             ;Shift 4x Left
   f838   48                    LSLA
   f839   48                    LSLA
   f83a   48                    LSLA
   f83b   b7 01 d0              STAA  BUFFER+32  ;Save
   f83e   a6 01                 LDAA  1,X        ;X+4=Address char2
   f840   bd e3 36              JSR   CHR2VAL
   f843   ba 01 d0              ORAA  BUFFER+32
   f846   b7 01 d0              STAA  BUFFER+32
   f849   a6 02                 LDAA  2,X        ;X+4=Address char3
   f84b   bd e3 36              JSR   CHR2VAL
   f84e   48                    LSLA
   f84f   48                    LSLA
   f850   48                    LSLA
   f851   48                    LSLA
   f852   b7 01 d1              STAA  BUFFER+33
   f855   a6 03                 LDAA  3,X        ;X+4=Address char4
   f857   bd e3 36              JSR   CHR2VAL
   f85a   ba 01 d1              ORAA  BUFFER+33
   f85d   b7 01 d1              STAA  BUFFER+33
   f860   39                    RTS
                        
                        ;********************************************************************
                        ;GETVARA  Set X to the address of the 8bit Value of the variable name(A-Y) from A 
                        ;********************************************************************
   f861   80 40         GETVARA SUBA #$40
   f863   b7 01 56              STAA VARPNT+1
   f866   48                    ASLA
   f867   bb 01 56              ADDA VARPNT+1
   f86a   b7 01 56              STAA VARPNT+1
   f86d   fe 01 55              LDX VARPNT
   f870   08                    INX
   f871   39                    RTS
                        
                        ;********************************************************************
                        ;GETVALU  Get the LOW 8bit Value of the variable name(A-Y) from A 
                        ;********************************************************************
   f872   ff 01 28      GETVALU STX   SAVEXP
   f875   bd f8 61              JSR   GETVARA
   f878   a6 00                 LDAA  0,X
   f87a   fe 01 28              LDX   SAVEXP
   f87d   39                    RTS
                        ;********************************************************************
                        ;SETVALU Set the LOW 8bit Value of the variable name(A-Y) from A = B 
                        ;********************************************************************
   f87e   ff 01 28      SETVALU STX   SAVEXP
   f881   bd f8 61              JSR   GETVARA
   f884   e7 00                 STAB  0,X
   f886   fe 01 28              LDX   SAVEXP
   f889   39                    RTS
                        
                        ;*************************************
                        ; SRCHA
                        ; Get the byte pointed to by SRCHPA in A
                        ; Optionally Increment SRCHPA first
                        ;*************************************
   f88a   bd f8 99      SRCHAI  JSR   INCSCHA   ; Increment 16 bit pointer SRCHPA
   f88d   ff 02 92      SRCHA   STX   PUSHXP    ; Save X
   f890   fe 02 94              LDX   SRCHPA    ; SRCHPA->X
   f893   a6 00                 LDAA  0,X       ; Get Value -> A
   f895   fe 02 92              LDX   PUSHXP    ; Restore X
   f898   39                    RTS
                         
                        ; SUBROUTINE Increment 16bit pointer SRCHPA          
   f899   7c 02 95      INCSCHA INC   SRCHPA+1
   f89c   26 03                 BNE   IECSHAX
   f89e   7c 02 94              INC   SRCHPA
   f8a1   39            IECSHAX RTS
                        
                        ; SUBROUTINE Decrement 16bit pointer SRCHPA
   f8a2   0d            DECSCHA SEC 
   f8a3   7d 02 95              TST   SRCHPA+1
   f8a6   26 03                 BNE   DECSHA1       
   f8a8   7a 02 94              DEC   SRCHPA
   f8ab   7a 02 95      DECSHA1 DEC   SRCHPA+1       
   f8ae   39                    RTS
                                
   f8af   01            ENDBASIC NOP         
                        ;***********************************************************************
                        ;******************************************************************  
   fb00                         ORG  $FB00    ; ##RAM## Opcode Type Lookup Table (fixed ROM addr. $FB00)
                        ;******************************************************************
   fb00   00 00 21 00   OPCDTYPE   FCB $00,$00,$21,$00,$04,$08,$31,$22,$11,$21,$31,$22,$11,$21,$31,$22
   fb04   04 08 31 22   
   fb08   11 21 31 22   
   fb0c   11 21 31 22   
   fb10   62 83 8c 8e   OPCDEXCP   FCB $62,$83,$8C,$8E,$C3,$CC,$CE,$00
   fb14   c3 cc ce 00   
                        
   fb20                         ORG  $FB20    ; Mnemonic Lookup Table   0x02A5 (677)bytes  $FB20-$FD72
                        ;******************************************************************
                        ;Mnemonic Lookup Table High Opcodes x40-xFF    (fixed ROM addr. $FB20)
                        ;******************************************************************
   fb20   41 44 43 41   MNETBLH     FCC "ADCA"
   fb24   89 99 a9 b9               FCB $89,$99,$A9,$B9
   fb28   41 44 43 42               FCC "ADCB"
   fb2c   c9 d9 e9 f9               FCB $C9,$D9,$E9,$F9
   fb30   41 44 44 41               FCC "ADDA"
   fb34   8b 9b ab bb               FCB $8B,$9B,$AB,$BB
   fb38   41 44 44 42               FCC "ADDB"
   fb3c   cb db eb fb               FCB $CB,$DB,$EB,$FB
   fb40   41 44 44 44               FCC "ADDD"
   fb44   c3 d3 e3 f3               FCB $C3,$D3,$E3,$F3            
   fb48   41 4e 44 41               FCC "ANDA"
   fb4c   84 94 a4 b4               FCB $84,$94,$A4,$B4
   fb50   41 4e 44 42               FCC "ANDB"
   fb54   c4 d4 e4 f4               FCB $C4,$D4,$E4,$F4            
   fb58   42 49 54 41               FCC "BITA"
   fb5c   85 95 a5 b5               FCB $85,$95,$A5,$B5                        
   fb60   42 49 54 42               FCC "BITB"
   fb64   c5 d5 e5 f5               FCB $C5,$D5,$E5,$F5                        
   fb68   42 53 52 20               FCC "BSR "
   fb6c   8d 00 00 00               FCB $8D,0  ,0  ,0                          
   fb70   43 4d 50 41               FCC "CMPA"
   fb74   81 91 a1 b1               FCB $81,$91,$A1,$B1                        
   fb78   43 4d 50 42               FCC "CMPB"
   fb7c   c1 d1 e1 f1               FCB $C1,$D1,$E1,$F1                        
   fb80   43 50 58 20               FCC "CPX "
   fb84   8c 9c ac bc               FCB $8C,$9C,$AC,$BC                        
   fb88   45 4f 52 41               FCC "EORA"
   fb8c   88 98 a8 b8               FCB $88,$98,$A8,$B8                        
   fb90   45 4f 52 42               FCC "EORB"
   fb94   c8 d8 e8 f8               FCB $C8,$D8,$E8,$F8                        
   fb98   4a 53 52 20               FCC "JSR "
   fb9c   01 9d ad bd               FCB $01,$9D,$AD,$BD                          
   fba0   4c 44 41 41               FCC "LDAA"
   fba4   86 96 a6 b6               FCB $86,$96,$A6,$B6                        
   fba8   4c 44 41 42               FCC "LDAB"
   fbac   c6 d6 e6 f6               FCB $C6,$D6,$E6,$F6                        
   fbb0   4c 44 53 20               FCC "LDS "
   fbb4   8e 9e ae be               FCB $8E,$9E,$AE,$BE                        
   fbb8   4c 44 58 20               FCC "LDX "
   fbbc   ce de ee fe               FCB $CE,$DE,$EE,$FE                        
   fbc0   4f 52 41 41               FCC "ORAA"
   fbc4   8a 9a aa ba               FCB $8A,$9A,$AA,$BA                        
   fbc8   4f 52 41 42               FCC "ORAB"
   fbcc   ca da ea fa               FCB $CA,$DA,$EA,$FA                        
   fbd0   53 42 43 41               FCC "SBCA"
   fbd4   82 92 a2 b2               FCB $82,$92,$A2,$B2                        
   fbd8   53 42 43 42               FCC "SBCB"
   fbdc   c2 d2 e2 f2               FCB $C2,$D2,$E2,$F2                        
   fbe0   53 54 41 41               FCC "STAA"
   fbe4   01 97 a7 b7               FCB $01,$97,$A7,$B7                          
   fbe8   53 54 41 42               FCC "STAB"
   fbec   01 d7 e7 f7               FCB $01,$D7,$E7,$F7                          
   fbf0   53 54 44 20               FCC "STD "
   fbf4   01 dd ed fd               FCB $01,$DD,$ED,$FD                          
   fbf8   53 54 53 20               FCC "STS "
   fbfc   01 9f af bf               FCB $01,$9F,$AF,$BF                          
   fc00   53 54 58 20               FCC "STX "
   fc04   01 df ef ff               FCB $01,$DF,$EF,$FF                          
   fc08   53 55 42 41               FCC "SUBA"
   fc0c   80 90 a0 b0               FCB $80,$90,$A0,$B0                        
   fc10   53 55 42 42               FCC "SUBB"
   fc14   c0 d0 e0 f0               FCB $C0,$D0,$E0,$F0                        
   fc18   00 00 00 00               FCB 0,0,0,0,0,0,0,0
   fc1c   00 00 00 00   
                        ;******************************************************************            
                        ; MNETBLM   Mnemonic Table M      (exception opcodes)     
                        ;******************************************************************            
   fc20   43 4c 52 20   MNETBLM     FCC "CLR "
   fc24   6f 7f 4f 5f               FCB $6F,$7F,$4F,$5F            
   fc28   43 4f 4d 20               FCC "COM "
   fc2c   63 73 43 53               FCB $63,$73,$43,$53                        
   fc30   4e 45 47 20               FCC "NEG "
   fc34   60 70 40 50               FCB $60,$70,$40,$50                        
   fc38   44 45 43 20               FCC "DEC "
   fc3c   6a 7a 4a 5a               FCB $6A,$7A,$4A,$5A                        
   fc40   49 4e 43 20               FCC "INC "
   fc44   6c 7c 4c 5c               FCB $6C,$7C,$4C,$5C                        
   fc48   52 4f 4c 20               FCC "ROL "
   fc4c   69 79 49 59               FCB $69,$79,$49,$59                        
   fc50   52 4f 52 20               FCC "ROR "
   fc54   66 76 46 56               FCB $66,$76,$46,$56                        
   fc58   41 53 4c 20               FCC "ASL "
   fc5c   68 78 48 58               FCB $68,$78,$48,$58                        
   fc60   41 53 52 20               FCC "ASR "
   fc64   67 77 47 57               FCB $67,$77,$47,$57                        
   fc68   4c 53 52 20               FCC "LSR "
   fc6c   64 74 44 54               FCB $64,$74,$44,$54                        
   fc70   54 53 54 20               FCC "TST "
   fc74   6d 7d 4d 5d               FCB $6D,$7D,$4D,$5D                        
   fc78   4a 4d 50 20               FCC "JMP "
   fc7c   6e 7e 7e 7e               FCB $6E,$7E,$7E,$7E                          
   fc80   00 00 00 00               FCB 0,0,0,0,0,0,0,0
   fc84   00 00 00 00   
                        ;******************************************************************
                        ;MNETBLL   Mnemonic Table L  Opcodes x01-x3F   (0 or 1 parm)
                        ;******************************************************************
   fc88   41 42 41 20   MNETBLL     FCC "ABA "
   fc8c   1b                        FCB $1B            
   fc8d   41 42 58 20               FCC "ABX "
   fc91   3a                        FCB $3A                        
   fc92   42 43 43 20               FCC "BCC "
   fc96   24                        FCB $24                        
   fc97   42 43 53 20               FCC "BCS "
   fc9b   25                        FCB $25                        
   fc9c   42 45 51 20               FCC "BEQ "
   fca0   27                        FCB $27                        
   fca1   42 47 45 20               FCC "BGE "
   fca5   2c                        FCB $2C                        
   fca6   42 47 54 20               FCC "BGT "
   fcaa   2e                        FCB $2E                        
   fcab   42 48 49 20               FCC "BHI "
   fcaf   22                        FCB $22                        
   fcb0   42 4c 45 20               FCC "BLE "
   fcb4   2f                        FCB $2F                        
   fcb5   42 4c 53 20               FCC "BLS "
   fcb9   23                        FCB $23                        
   fcba   42 4c 54 20               FCC "BLT "
   fcbe   2d                        FCB $2D                        
   fcbf   42 4d 49 20               FCC "BMI "
   fcc3   2b                        FCB $2B                        
   fcc4   42 4e 45 20               FCC "BNE "
   fcc8   26                        FCB $26                        
   fcc9   42 50 4c 20               FCC "BPL "
   fccd   2a                        FCB $2A                        
   fcce   42 52 41 20               FCC "BRA "
   fcd2   20                        FCB $20                        
   fcd3   42 52 4e 20               FCC "BRN "
   fcd7   21                        FCB $21                        
   fcd8   42 56 43 20               FCC "BVC "
   fcdc   28                        FCB $28                        
   fcdd   42 56 53 20               FCC "BVS "
   fce1   29                        FCB $29                        
   fce2   43 42 41 20               FCC "CBA "
   fce6   11                        FCB $11                        
   fce7   43 4c 43 20               FCC "CLC "
   fceb   0c                        FCB $0C                        
   fcec   43 4c 49 20               FCC "CLI "
   fcf0   0e                        FCB $0E                        
   fcf1   43 4c 56 20               FCC "CLV "
   fcf5   0a                        FCB $0A                        
   fcf6   44 41 41 20               FCC "DAA "
   fcfa   19                        FCB $19                        
   fcfb   44 45 53 20               FCC "DES "
   fcff   34                        FCB $34                        
   fd00   44 45 58 20               FCC "DEX "
   fd04   09                        FCB $09                        
   fd05   49 4e 53 20               FCC "INS "
   fd09   31                        FCB $31                        
   fd0a   49 4e 58 20               FCC "INX "
   fd0e   08                        FCB $08                        
   fd0f   4e 4f 50 20               FCC "NOP "
   fd13   01                        FCB $01                        
   fd14   50 53 48 41               FCC "PSHA"
   fd18   36                        FCB $36                        
   fd19   50 53 48 42               FCC "PSHB"
   fd1d   37                        FCB $37                        
   fd1e   50 55 4c 41               FCC "PULA"
   fd22   32                        FCB $32                        
   fd23   50 55 4c 42               FCC "PULB"
   fd27   33                        FCB $33                        
   fd28   52 54 49 20               FCC "RTI "
   fd2c   3b                        FCB $3B                        
   fd2d   52 54 53 20               FCC "RTS "
   fd31   39                        FCB $39                        
   fd32   53 42 41 20               FCC "SBA "
   fd36   10                        FCB $10                        
   fd37   53 45 43 20               FCC "SEC "
   fd3b   0d                        FCB $0D                        
   fd3c   53 45 49 20               FCC "SEI "
   fd40   0f                        FCB $0F                        
   fd41   53 45 56 20               FCC "SEV "
   fd45   0b                        FCB $0B                        
   fd46   53 57 49 20               FCC "SWI "
   fd4a   3f                        FCB $3F                        
   fd4b   54 41 42 20               FCC "TAB "
   fd4f   16                        FCB $16                        
   fd50   54 41 50 20               FCC "TAP "
   fd54   06                        FCB $06                        
   fd55   54 42 41 20               FCC "TBA "
   fd59   17                        FCB $17                        
   fd5a   54 50 41 20               FCC "TPA "
   fd5e   07                        FCB $07                        
   fd5f   54 53 58 20               FCC "TSX "
   fd63   30                        FCB $30                        
   fd64   54 58 53 20               FCC "TXS "
   fd68   35                        FCB $35                        
   fd69   57 41 49 20               FCC "WAI "
   fd6d   3e                        FCB $3E                        
   fd6e   00 00 00 00   MNETBLEND   FCB 0,0,0,0,0
   fd72   00            
                                
                        
                        ;;************************************************************************
                        ;;  External Call Jump Table  
                        ;;  Fixed locations in ROM map to subroutines that may re-locate
                        ;;************************************************************************
   ffc8                 JUMPTBL        org   $FFC8       ; FFC8-FFF*  (fixed ROM addr.)
   ffc8   7e e1 c2              JMP   DEL5A              ;Delay  A*5 ms
   ffcb   7e e1 da              JMP   DELAYA             ;Delay  A ms
   ffce   7e e1 e7              JMP   DELAYB             ;Delay B * 6 us
   ffd1   7e e2 37              JMP   OUTCHR             ;Send byte in A to Serial Port
   ffd4   7e e2 81              JMP   GETBYTE            ;wait for a serial byte and return in A
   ffd7   7e e2 a8              JMP   INCHRE             ;wait for a serial byte and return in A with echo
   ffda   7e e3 44              JMP   PUTS               ;Transmit data indexed by X
   ffdd   7e e3 5d              JMP   OUTHEX             ;Output A as 2 HEX digits
   ffe0   7e e2 b1              JMP   GETHEXB            ;Wait until a HEX byte is entered 
   ffe3   7e e2 fe              JMP   INHEXB             ;Input 2 hex digits return with byte value in A
   ffe6   7e e2 e8              JMP   GETADDR            ;Get 4 byte address, save in ADDRH & ADDRL
   ffe9   7e e2 0d              JMP   BEEPBA             ;BEEP A=Duration Count and B=Frequency Count
   ffec   7e e2 7a              JMP   TESTKEY            ; Return Z=1 if start bit encountered        
                                
                        ;*************************************
                        ; Vector Table  Not for local version
                        ;*************************************
   fff8                     ORG $FFF8
   fff8   00                FCB $00        ;IRQ Vector
   fff9   c0                FCB IRQVECT
   fffa   00                FCB $00        ;SW IRQ Vector
   fffb   c3                FCB SWIVECT
   fffc   e8 f1             FDB NMIISR     ;NMI Vector
   fffe   e0 00             FDB RESET      ;Reset Address
                        
                        
   0000                     END
efac  ADD           efaf  ADD1          e8e1  ADDB2X        e8ed  ADDB2X1   
0082  ADDRH         0083  ADDRL         0151  AESTK         014f  ANUMB     
0148  ARRTAB        e6a2  ASM201        e6b2  ASM202        e752  ASM2END   
e74c  ASM2ERX       e67a  ASM2MEM       e71f  ASM2PR        e6be  ASM2SH    
e6d9  ASM2SH1       e6e2  ASM2SH2       e6eb  ASM2SM        e706  ASM2SM1   
e70f  ASM2SM2       e71a  ASM2SM3       e6a1  ASM2X1        e82c  ASMCMP3   
e83c  ASMCP3X       e72b  ASMPAD        e813  ASMSH3        e81d  ASMSH3N   
e81a  ASMSH3X       e7f1  ASMSH4        e803  ASMSH4N       e800  ASMSH4X   
028c  ASTACK        007f  BACKSP        f2fd  BASIC         f305  BASIC0    
f308  BASIC1        f32b  BASIC2        02b0  BASICTOP      0136  BASLIN    
0134  BASPNT        e20d  BEEPBA        e1ed  BLINKB1       e1eb  BLINKBA   
0150  BNUMB         e8fa  BOOTMSG       f2ed  BUF3          01b0  BUFFER    
01ac  BUFNXT        f2d1  BUFWRT        001b  CANCEL        f23b  CAPPEN    
f06c  CCEXIT        f029  CCODE         f80e  CHKBRK        f81e  CHKNBRK   
e1ac  CHK_??        e14e  CHK_A         e188  CHK_AT        e167  CHK_AX    
e089  CHK_B         e096  CHK_BL        e0bd  CHK_D         e0ab  CHK_DL    
e0f5  CHK_F         e0ff  CHK_G         e115  CHK_GL        e178  CHK_IHR   
e144  CHK_L         e199  CHK_M         e195  CHK_ML        e09d  CHK_N     
e0cf  CHK_S         e121  CHK_T         e07e  CHK_X         e16a  CHK_Z     
e336  CHR2VAL       e33d  CHR2VL1       f13b  CLIST         f144  CLIST1    
f168  CLIST2        f16c  CLIST3        f17a  CLIST4        f17d  CLIST5    
e5b2  CLRDAB1       e5ad  CLRDABUF      eb04  CLRVMEM       f7d3  CMPR      
f7ea  CMPR1         ec52  CNTLIN        00c6  CNTR5MS       eb00  COLDST    
ebec  COMEND        eb4e  COMMAN        0091  COUNT_A       0092  COUNT_B   
0093  COUNT_C       ec8b  CREND         ec7f  CRLF          ec89  CRLFST    
2001  CTLRA         2003  CTLRB         f832  CVTADDR       e77f  CVTPRM1   
e79a  CVTPRM2       e778  CVTPRMS       f3fb  DBLLTR        f8a2  DECSCHA   
f8ab  DECSHA1       ec50  DEL           f258  DEL2          f26f  DEL4      
f27a  DEL5          e1c2  DEL5A         e1c3  DEL5A1        e1da  DELAYA    
e1db  DELAYA1       e1e7  DELAYB        f245  DELETE        f284  DELEX     
f21e  DELREP        e876  DESPACE       e8a1  DESPACX       0298  DESTPA    
029a  DESTPB        f5cc  DIM           f5cf  DIM1          f5da  DIM111    
f613  DIM2          f624  DIM3          f63e  DIM6          f668  DIM7      
0140  DIMCAL        f610  DIMER1        f60e  DIMERR        f679  DIMEX     
013e  DIMPNT        0199  DIMVAR        00a0  DISABUF       0098  DISABUFP  
009a  DISADD1       009c  DISADD2       ef4b  DIV           ef71  DIV163    
ef7e  DIV165        ef7f  DIV167        ef92  DIV169        ef5a  DIV33     
ef5c  DIV4          ef67  DIV5          e3c6  DMP2561       e3e1  DMP256X   
e20f  DOBEEP        e214  DOBEP1        e236  DOBEPX        e1af  DOINCA    
e1b5  DOINCA1       e1c1  DOINCAX       e19d  DOMENU        f1d1  DOPEEK    
f1ea  DOPOKE        e87d  DSPACE1       e887  DSPACE2       e891  DSPACE3   
e368  DUMP16        e37e  DUMP161       e38c  DUMP162       e3a1  DUMP163   
e3a9  DUMP164       e3af  DUMP165       e3c2  DUMP256       ec66  ECHO      
f8af  ENDBASIC      01ae  ENDBUF        f514  ENLEXT        f507  ENLINE    
ebff  ERRMS1        ec07  ERRMS2        f0d0  ERROR         f0f6  ERROR1    
f0fd  ERROR2        eec3  EXPR          eed2  EXPR0         eed7  EXPR00    
eed9  EXPR1         eee8  EXPR2         eef4  EXPR3         ee7f  FACT      
ee8b  FACT0         ee91  FACT1         eea1  FACT2         e47f  FILL01    
e489  FILLEX        e44c  FILLMEM       efd4  FIND0         efe2  FIND1     
efe3  FIND2         eff2  FIND3         eff3  FIND4         efd1  FINDN1    
efc3  FINDNO        0088  FLAGS_A       f695  FOR           f6a0  FOR1      
f6b3  FOR11         f6c7  FOR2          f6ca  FOR3          f6f8  FOR8      
0153  FORPNT        0169  FORSTK        f7e8  FUNNY         e2e8  GETADDR   
e2fd  GETADDX       e2ee  GETADR1       e282  GETBT1        e28c  GETBT2    
e291  GETBT3        e281  GETBYTE       e2cb  GETHEX1       e2d7  GETHEX3   
e2e2  GETHEX4       e2e6  GETHEX5       e2b1  GETHEXB       e3e2  GETIHEX   
e078  GETMOPT       f830  GETPRM1       f820  GETPRMP       e8b1  GETSTR    
e8b4  GETSTR1       e8cb  GETSTR2       e8d1  GETSTR3       e8dc  GETSTRX   
f872  GETVALU       f861  GETVARA       e41c  GIHCSUM       e43d  GIHERR2   
e442  GIHEXIT       e444  GIHEXX1       eb7b  GOLIST        f32d  GOSUB     
f343  GOSUB1        f358  GOTO          f368  GOTO2         efef  HIBALL    
0132  HIGHLN        f8a1  IECSHAX       ec59  IEXIT         f775  IF        
f78d  IF2           ebac  IMPLET        0081  INBYTE        ec69  INCH      
e2a8  INCHRE        f899  INCSCHA       ecd3  IND           0084  INDEX1    
0086  INDEX2        0120  INDEX_1       0122  INDEX_2       0124  INDEX_3   
0126  INDEX_4       028e  INDEX_5       0290  INDEX_6       e2fe  INHEXB    
e31c  INHEXB2       e31b  INHEXBX       eb0c  INITVM        f45e  INNERR    
f463  INNEX         f46c  INNEX2        f410  INNUM         f41f  INNUM0    
f428  INNUM1        f42b  INNUM2        f3d6  INPERR        f3f3  INPEX     
f3a9  INPUT         f3b2  INPUT0        f3be  INPUT1        f3c9  INPUT2    
f3e1  INPUT4        f3d9  INPUTS        f28b  INS1          f2b3  INS2      
f285  INSERT        f41c  INTSTN        f000  INXSKP        00c0  IRQVECT   
ffc8  JUMPTBL       ec23  KEYB10        ec26  KEYB11        ec3a  KEYB55    
ec11  KEYBD         ec15  KEYBD0        ec1a  KEYBD1        ec2e  KEYBD2    
ec46  KEYBD3        e050  KEYCHK        e053  KEYCHK1       014a  KEYWD     
f573  KIOK          e06e  LEDOFF        f57d  LET           f585  LET0      
f587  LET00         f58a  LET1          f592  LET2          f596  LET3      
ed06  LEXIT         f00e  LINE1         009e  LINECT        f004  LINENO    
ecee  LIST          ecf9  LIST0         e4b2  LIST01        e4bd  LIST02    
e4da  LIST03        e4e7  LIST04        e4f6  LIST05        e533  LIST06    
e53e  LIST07        e546  LIST08        e570  LIST09        ecfc  LIST1     
e576  LIST10        e5ac  LISTEX        e48a  LISTMEM       e58b  LISTNXT   
0001  LOCAL         f0c5  LOOP2         f032  LOOP3         f03e  LOOP4     
f04b  LOOP5         f057  LOOP6         f05b  LOOP7         f06b  LOOP8     
e5a9  LSTCKE3       e59b  LSTCKEA       0072  MAXLIN        f804  MAYEQ     
ef38  MDS2          ef45  MDS3          ef29  MDSIGN        0146  MEMEND    
e1a6  MENUXOK       fd6e  MNETBLEND     fb20  MNETBLH       fc88  MNETBLL   
fc20  MNETBLM       e83d  MOVPRM        e848  MOVPRM1       e86e  MOVPRM3   
e875  MOVPRMX       eef5  MPY           eefd  MPY4          ef0e  MPY5      
ef21  MPY6          ef09  MPYERR        ea8d  MSGATNR       ea91  MSGBASIC  
ea6d  MSGENDAD      ea45  MSGENTA       ea3b  MSGERR        e926  MSGMENU   
ea31  MSGNL         ea34  MSGOK         ea55  MSGSTART      ea85  MSGVAL    
f809  MYNTEQ        014d  NCMPR         ef96  NEG           efa3  NEGAB     
f0b1  NEWL3         f0a5  NEWLIN        f238  NEXIT         f713  NEXT      
f71e  NEXT1         f72f  NEXT2         f74b  NEXT3         f74e  NEXT4     
f768  NEXT5         f770  NEXT6         012a  NEXTBA        e402  NEXTIHB   
e8f1  NMIISR        e8f9  NMIISRX       f800  NOCMPR        ee53  NONO      
f203  NUM1          f200  NUMBER        f01e  NXTL12        f01b  NXTLIN    
f2c7  OFFSET        f802  OKCMPR        0094  OPCD          fb10  OPCDEXCP  
fb00  OPCDTYPE      e632  OPCEXCP       e637  OPCEXP1       0097  OPCFLAGS  
e61a  OPCTYPE       e644  OPCTYPX       0080  OUTBYTE       ec63  OUTCH     
e237  OUTCHR        e24c  OUTCHR1       e25b  OUTCHR2       e25d  OUTCHR3   
e35d  OUTHEX        ed18  OUTLI1        ed2b  OUTLI2        ed07  OUTLIN    
ec78  OUTNCR        e34b  OUTNIBH       e34f  OUTNIBL       e359  OUTNIBX   
e75b  OUTPRM1       e76f  OUTPRM2       e753  OUTPRMS       ec75  OUTPU2    
ec77  OUTPU3        ec71  OUTPUT        f2f8  OVERFL        0130  PACKLN    
00b0  PARMBUF       00b5  PARMLEN       f181  PATCH         ebe3  PAUMSG    
f387  PAUSE         f39c  PAUSE1        f3a6  PAUSE2        ebfa  PGCNTL    
2000  PORTA         0090  PORTAV        2002  PORTB         0142  PRCNT     
f4ff  PREND         f4fc  PRI999        f4cf  PRIN77        f4df  PRIN88    
f4f7  PRIN99        ed3e  PRINSP        f471  PRINT         f474  PRINT0    
f47c  PRINT1        f48b  PRINT2        f493  PRINT4        f4a5  PRINT5    
f4ac  PRINT6        f4c3  PRINT7        f4d9  PRINT8        f4c0  PRINTE    
f4e7  PRLOOP        f519  PRN           f535  PRN0          f53b  PRN1      
f53e  PRN2          f549  PRN5          f55d  PRN6          f567  PRN7      
eb4b  PROGM         ebf7  PROMPT        ee6c  PULLAE        ecac  PULLX     
ee57  PULPSH        ee59  PUSHAE        0138  PUSHTX        ec91  PUSHX     
0292  PUSHXP        e5c9  PUTMNE1       e5eb  PUTMNE2       e5f3  PUTMNE3   
e600  PUTMNE4       e611  PUTMNE5       e5c4  PUTMNEM       e344  PUTS      
e340  PUTS2         ed5a  RAND1         ed46  RANDOM        ebef  RDYMSG    
f09c  READY         008e  REC_CSUM      008c  REC_LEN       008d  REC_TYPE  
f7c4  REL44         f797  RELOP         f7a2  RELOP0        f7b0  RELOP1    
f7b4  RELOP2        f7b8  RELOP3        f7bb  RELOP4        f7cc  RELOP5    
f5c6  REMARK        f234  REPLAC        e000  RESET         f37a  RETUR1    
f36d  RETURN        013c  RNDVAL        0095  ROWADDH       0096  ROWADDL   
f105  RUN           f125  RUN1          f132  RUN2          0128  SAVEXP    
0157  SBRPNT        0159  SBRSTK        e0de  SETMEM        e0f2  SETMEMX   
e7c3  SETTYP1       e7d4  SETTYP2       e7bc  SETTYP4       e7e6  SETTYPA   
e7b1  SETTYPE       e7e9  SETTYPN       e7ec  SETTYPX       f87e  SETVALU   
e8a4  SHFTBL1       e8a2  SHIFTBL       f5a2  SIZE          f003  SKIPEX    
effa  SKIPSP        012e  SOURCE        f88d  SRCHA         f88a  SRCHAI    
e648  SRCHMH1       e650  SRCHMH2       e662  SRCHMHX       e666  SRCHML1   
e66c  SRCHML2       e679  SRCHMLX       e645  SRCHMNH       e663  SRCHMNL   
0294  SRCHPA        0296  SRCHPB        f076  START         f08c  START1    
f084  START2        ecb8  STORE         f688  STRSU2        f68f  STRSU3    
f680  STRSUB        efaa  SUB           edd2  SUBER1        f620  SUBERR    
00c3  SWIVECT       f191  SYSCALL       f1cb  SYSCALX       0089  TEMP_01   
008a  TEMP_02       008b  TEMP_03       eea6  TERM          eea8  TERM0     
eeb6  TERM1         eec2  TERM2         e27a  TESTKEY       ee4b  TESTNO    
014e  TNUMB         014c  TSIGN         ee1a  TST666        ee43  TSTLTR    
f400  TSTN          f40a  TSTN0         f40c  TSTN1         ed79  TSTV      
ed85  TSTV1         ed8f  TSTV2         edae  TSTV20        edc5  TSTV22    
edd5  TSTV3         ede9  TSTV4         edef  TSTV5         edf6  TSTV6     
ee1d  TSTV7         ee2d  TSTV8         ee3a  TSTV9         edc2  TSTVER    
e130  TXTMEM        e141  TXTMEMX       0155  VARPNT        0200  VARTAB    
012c  WORKBA        013a  XSTACK        ee55  YESNO         
